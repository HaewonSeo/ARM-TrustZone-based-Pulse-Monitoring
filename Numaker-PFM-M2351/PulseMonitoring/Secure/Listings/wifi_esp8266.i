# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 358 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c" 2
# 44 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h" 1
# 27 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 1 3
# 51 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
    typedef unsigned int size_t;






extern __attribute__((__nothrow__)) void *memcpy(void * __restrict ,
                    const void * __restrict , size_t ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) void *memmove(void * ,
                    const void * , size_t ) __attribute__((__nonnull__(1,2)));
# 77 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strcpy(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) char *strncpy(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
# 93 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strcat(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) char *strncat(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
# 117 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int memcmp(const void * , const void * , size_t ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int strcmp(const char * , const char * ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) int strncmp(const char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 141 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int strcasecmp(const char * , const char * ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int strncasecmp(const char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 158 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int strcoll(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 169 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strxfrm(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(2)));
# 193 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void *memchr(const void * , int , size_t ) __attribute__((__nonnull__(1)));
# 209 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strchr(const char * , int ) __attribute__((__nonnull__(1)));
# 218 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strcspn(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 232 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strpbrk(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 247 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strrchr(const char * , int ) __attribute__((__nonnull__(1)));
# 257 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strspn(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 270 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strstr(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 280 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strtok(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(2)));
extern __attribute__((__nothrow__)) char *_strtok_r(char * , const char * , char ** ) __attribute__((__nonnull__(2,3)));
# 321 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void *memset(void * , int , size_t ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) char *strerror(int );







extern __attribute__((__nothrow__)) size_t strlen(const char * ) __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) size_t strlcpy(char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 362 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strlcat(char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 388 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void _membitcpybl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpybb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpyhl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpyhb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpywl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpywb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovebl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovebb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovehl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovehb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovewl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovewb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
# 28 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h" 2

# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include\\Driver_WiFi.h" 1
# 39 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include\\Driver_WiFi.h"
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include/Driver_Common.h" 1
# 37 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include/Driver_Common.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 1 3
# 38 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
  typedef signed int ptrdiff_t;
# 71 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
      typedef unsigned short wchar_t;
# 95 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stddef.h" 3
  typedef long double max_align_t;
# 38 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include/Driver_Common.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 1 3
# 56 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
typedef signed char int8_t;
typedef signed short int int16_t;
typedef signed int int32_t;
typedef signed long long int int64_t;


typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;





typedef signed char int_least8_t;
typedef signed short int int_least16_t;
typedef signed int int_least32_t;
typedef signed long long int int_least64_t;


typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long int uint_least64_t;




typedef signed int int_fast8_t;
typedef signed int int_fast16_t;
typedef signed int int_fast32_t;
typedef signed long long int int_fast64_t;


typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long int uint_fast64_t;






typedef signed int intptr_t;
typedef unsigned int uintptr_t;



typedef signed long long intmax_t;
typedef unsigned long long uintmax_t;
# 39 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include/Driver_Common.h" 2
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdbool.h" 1 3
# 40 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include/Driver_Common.h" 2






typedef struct _ARM_DRIVER_VERSION {
  uint16_t api;
  uint16_t drv;
} ARM_DRIVER_VERSION;
# 63 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include/Driver_Common.h"
typedef enum _ARM_POWER_STATE {
  ARM_POWER_OFF,
  ARM_POWER_LOW,
  ARM_POWER_FULL
} ARM_POWER_STATE;
# 40 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include\\Driver_WiFi.h" 2
# 98 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include\\Driver_WiFi.h"
typedef struct ARM_WIFI_CONFIG_s {
  const char *ssid;
  const char *pass;
        uint8_t security;
        uint8_t ch;
        uint8_t reserved;
        uint8_t wps_method;
  const char *wps_pin;
} ARM_WIFI_CONFIG_t;




typedef struct ARM_WIFI_SCAN_INFO_s {
  char ssid[32+1];
  uint8_t bssid[6];
  uint8_t security;
  uint8_t ch;
  uint8_t rssi;
} ARM_WIFI_SCAN_INFO_t;




typedef struct ARM_WIFI_NET_INFO_s {
  char ssid[32+1];
  char pass[64+1];
  uint8_t security;
  uint8_t ch;
  uint8_t rssi;
} ARM_WIFI_NET_INFO_t;
# 597 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/Driver/Include\\Driver_WiFi.h"
typedef void (*ARM_WIFI_SignalEvent_t) (uint32_t event, void *arg);





typedef struct _ARM_WIFI_CAPABILITIES {
  uint32_t station : 1;
  uint32_t ap : 1;
  uint32_t station_ap : 1;
  uint32_t wps_station : 1;
  uint32_t wps_ap : 1;
  uint32_t event_ap_connect : 1;
  uint32_t event_ap_disconnect : 1;
  uint32_t event_eth_rx_frame : 1;
  uint32_t bypass_mode : 1;
  uint32_t ip : 1;
  uint32_t ip6 : 1;
  uint32_t ping : 1;
  uint32_t reserved : 20;
} ARM_WIFI_CAPABILITIES;




typedef struct _ARM_DRIVER_WIFI {
  ARM_DRIVER_VERSION (*GetVersion) (void);
  ARM_WIFI_CAPABILITIES (*GetCapabilities) (void);
  int32_t (*Initialize) (ARM_WIFI_SignalEvent_t cb_event);
  int32_t (*Uninitialize) (void);
  int32_t (*PowerControl) (ARM_POWER_STATE state);
  int32_t (*GetModuleInfo) (char *module_info, uint32_t max_len);
  int32_t (*SetOption) (uint32_t interface, uint32_t option, const void *data, uint32_t len);
  int32_t (*GetOption) (uint32_t interface, uint32_t option, void *data, uint32_t *len);
  int32_t (*Scan) (ARM_WIFI_SCAN_INFO_t scan_info[], uint32_t max_num);
  int32_t (*Activate) (uint32_t interface, const ARM_WIFI_CONFIG_t *config);
  int32_t (*Deactivate) (uint32_t interface);
  uint32_t (*IsConnected) (void);
  int32_t (*GetNetInfo) (ARM_WIFI_NET_INFO_t *net_info);
  int32_t (*BypassControl) (uint32_t interface, uint32_t mode);
  int32_t (*EthSendFrame) (uint32_t interface, const uint8_t *frame, uint32_t len);
  int32_t (*EthReadFrame) (uint32_t interface, uint8_t *frame, uint32_t len);
  uint32_t (*EthGetRxFrameSize) (uint32_t interface);
  int32_t (*SocketCreate) (int32_t af, int32_t type, int32_t protocol);
  int32_t (*SocketBind) (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port);
  int32_t (*SocketListen) (int32_t socket, int32_t backlog);
  int32_t (*SocketAccept) (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
  int32_t (*SocketConnect) (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port);
  int32_t (*SocketRecv) (int32_t socket, void *buf, uint32_t len);
  int32_t (*SocketRecvFrom) (int32_t socket, void *buf, uint32_t len, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
  int32_t (*SocketSend) (int32_t socket, const void *buf, uint32_t len);
  int32_t (*SocketSendTo) (int32_t socket, const void *buf, uint32_t len, const uint8_t *ip, uint32_t ip_len, uint16_t port);
  int32_t (*SocketGetSockName) (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
  int32_t (*SocketGetPeerName) (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
  int32_t (*SocketGetOpt) (int32_t socket, int32_t opt_id, void *opt_val, uint32_t *opt_len);
  int32_t (*SocketSetOpt) (int32_t socket, int32_t opt_id, const void *opt_val, uint32_t opt_len);
  int32_t (*SocketClose) (int32_t socket);
  int32_t (*SocketGetHostByName) (const char *name, int32_t af, uint8_t *ip, uint32_t *ip_len);
  int32_t (*Ping) (const uint8_t *ip, uint32_t ip_len);
} const ARM_DRIVER_WIFI;
# 30 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h" 2
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h" 1
# 76 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
typedef struct {
  uint32_t api;
  uint32_t kernel;
} osVersion_t;


typedef enum {
  osKernelInactive = 0,
  osKernelReady = 1,
  osKernelRunning = 2,
  osKernelLocked = 3,
  osKernelSuspended = 4,
  osKernelError = -1,
  osKernelReserved = 0x7FFFFFFFU
} osKernelState_t;


typedef enum {
  osThreadInactive = 0,
  osThreadReady = 1,
  osThreadRunning = 2,
  osThreadBlocked = 3,
  osThreadTerminated = 4,
  osThreadError = -1,
  osThreadReserved = 0x7FFFFFFF
} osThreadState_t;


typedef enum {
  osPriorityNone = 0,
  osPriorityIdle = 1,
  osPriorityLow = 8,
  osPriorityLow1 = 8+1,
  osPriorityLow2 = 8+2,
  osPriorityLow3 = 8+3,
  osPriorityLow4 = 8+4,
  osPriorityLow5 = 8+5,
  osPriorityLow6 = 8+6,
  osPriorityLow7 = 8+7,
  osPriorityBelowNormal = 16,
  osPriorityBelowNormal1 = 16+1,
  osPriorityBelowNormal2 = 16+2,
  osPriorityBelowNormal3 = 16+3,
  osPriorityBelowNormal4 = 16+4,
  osPriorityBelowNormal5 = 16+5,
  osPriorityBelowNormal6 = 16+6,
  osPriorityBelowNormal7 = 16+7,
  osPriorityNormal = 24,
  osPriorityNormal1 = 24+1,
  osPriorityNormal2 = 24+2,
  osPriorityNormal3 = 24+3,
  osPriorityNormal4 = 24+4,
  osPriorityNormal5 = 24+5,
  osPriorityNormal6 = 24+6,
  osPriorityNormal7 = 24+7,
  osPriorityAboveNormal = 32,
  osPriorityAboveNormal1 = 32+1,
  osPriorityAboveNormal2 = 32+2,
  osPriorityAboveNormal3 = 32+3,
  osPriorityAboveNormal4 = 32+4,
  osPriorityAboveNormal5 = 32+5,
  osPriorityAboveNormal6 = 32+6,
  osPriorityAboveNormal7 = 32+7,
  osPriorityHigh = 40,
  osPriorityHigh1 = 40+1,
  osPriorityHigh2 = 40+2,
  osPriorityHigh3 = 40+3,
  osPriorityHigh4 = 40+4,
  osPriorityHigh5 = 40+5,
  osPriorityHigh6 = 40+6,
  osPriorityHigh7 = 40+7,
  osPriorityRealtime = 48,
  osPriorityRealtime1 = 48+1,
  osPriorityRealtime2 = 48+2,
  osPriorityRealtime3 = 48+3,
  osPriorityRealtime4 = 48+4,
  osPriorityRealtime5 = 48+5,
  osPriorityRealtime6 = 48+6,
  osPriorityRealtime7 = 48+7,
  osPriorityISR = 56,
  osPriorityError = -1,
  osPriorityReserved = 0x7FFFFFFF
} osPriority_t;


typedef void (*osThreadFunc_t) (void *argument);


typedef void (*osTimerFunc_t) (void *argument);


typedef enum {
  osTimerOnce = 0,
  osTimerPeriodic = 1
} osTimerType_t;
# 198 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
typedef enum {
  osOK = 0,
  osError = -1,
  osErrorTimeout = -2,
  osErrorResource = -3,
  osErrorParameter = -4,
  osErrorNoMemory = -5,
  osErrorISR = -6,
  osStatusReserved = 0x7FFFFFFF
} osStatus_t;



typedef void *osThreadId_t;


typedef void *osTimerId_t;


typedef void *osEventFlagsId_t;


typedef void *osMutexId_t;


typedef void *osSemaphoreId_t;


typedef void *osMemoryPoolId_t;


typedef void *osMessageQueueId_t;





typedef uint32_t TZ_ModuleId_t;




typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
  void *stack_mem;
  uint32_t stack_size;
  osPriority_t priority;
  TZ_ModuleId_t tz_module;
  uint32_t reserved;
} osThreadAttr_t;


typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
} osTimerAttr_t;


typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
} osEventFlagsAttr_t;


typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
} osMutexAttr_t;


typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
} osSemaphoreAttr_t;


typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
  void *mp_mem;
  uint32_t mp_size;
} osMemoryPoolAttr_t;


typedef struct {
  const char *name;
  uint32_t attr_bits;
  void *cb_mem;
  uint32_t cb_size;
  void *mq_mem;
  uint32_t mq_size;
} osMessageQueueAttr_t;






osStatus_t osKernelInitialize (void);






osStatus_t osKernelGetInfo (osVersion_t *version, char *id_buf, uint32_t id_size);



osKernelState_t osKernelGetState (void);



osStatus_t osKernelStart (void);



int32_t osKernelLock (void);



int32_t osKernelUnlock (void);




int32_t osKernelRestoreLock (int32_t lock);



uint32_t osKernelSuspend (void);



void osKernelResume (uint32_t sleep_ticks);



uint32_t osKernelGetTickCount (void);



uint32_t osKernelGetTickFreq (void);



uint32_t osKernelGetSysTimerCount (void);



uint32_t osKernelGetSysTimerFreq (void);
# 371 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr);




const char *osThreadGetName (osThreadId_t thread_id);



osThreadId_t osThreadGetId (void);




osThreadState_t osThreadGetState (osThreadId_t thread_id);




uint32_t osThreadGetStackSize (osThreadId_t thread_id);




uint32_t osThreadGetStackSpace (osThreadId_t thread_id);





osStatus_t osThreadSetPriority (osThreadId_t thread_id, osPriority_t priority);




osPriority_t osThreadGetPriority (osThreadId_t thread_id);



osStatus_t osThreadYield (void);




osStatus_t osThreadSuspend (osThreadId_t thread_id);




osStatus_t osThreadResume (osThreadId_t thread_id);




osStatus_t osThreadDetach (osThreadId_t thread_id);




osStatus_t osThreadJoin (osThreadId_t thread_id);


__attribute__((__noreturn__)) void osThreadExit (void);




osStatus_t osThreadTerminate (osThreadId_t thread_id);



uint32_t osThreadGetCount (void);





uint32_t osThreadEnumerate (osThreadId_t *thread_array, uint32_t array_items);
# 457 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags);




uint32_t osThreadFlagsClear (uint32_t flags);



uint32_t osThreadFlagsGet (void);






uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout);







osStatus_t osDelay (uint32_t ticks);




osStatus_t osDelayUntil (uint32_t ticks);
# 497 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
osTimerId_t osTimerNew (osTimerFunc_t func, osTimerType_t type, void *argument, const osTimerAttr_t *attr);




const char *osTimerGetName (osTimerId_t timer_id);





osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks);




osStatus_t osTimerStop (osTimerId_t timer_id);




uint32_t osTimerIsRunning (osTimerId_t timer_id);




osStatus_t osTimerDelete (osTimerId_t timer_id);







osEventFlagsId_t osEventFlagsNew (const osEventFlagsAttr_t *attr);




const char *osEventFlagsGetName (osEventFlagsId_t ef_id);





uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags);





uint32_t osEventFlagsClear (osEventFlagsId_t ef_id, uint32_t flags);




uint32_t osEventFlagsGet (osEventFlagsId_t ef_id);







uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout);




osStatus_t osEventFlagsDelete (osEventFlagsId_t ef_id);







osMutexId_t osMutexNew (const osMutexAttr_t *attr);




const char *osMutexGetName (osMutexId_t mutex_id);





osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout);




osStatus_t osMutexRelease (osMutexId_t mutex_id);




osThreadId_t osMutexGetOwner (osMutexId_t mutex_id);




osStatus_t osMutexDelete (osMutexId_t mutex_id);
# 610 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr);




const char *osSemaphoreGetName (osSemaphoreId_t semaphore_id);





osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout);




osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id);




uint32_t osSemaphoreGetCount (osSemaphoreId_t semaphore_id);




osStatus_t osSemaphoreDelete (osSemaphoreId_t semaphore_id);
# 646 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
osMemoryPoolId_t osMemoryPoolNew (uint32_t block_count, uint32_t block_size, const osMemoryPoolAttr_t *attr);




const char *osMemoryPoolGetName (osMemoryPoolId_t mp_id);





void *osMemoryPoolAlloc (osMemoryPoolId_t mp_id, uint32_t timeout);





osStatus_t osMemoryPoolFree (osMemoryPoolId_t mp_id, void *block);




uint32_t osMemoryPoolGetCapacity (osMemoryPoolId_t mp_id);




uint32_t osMemoryPoolGetBlockSize (osMemoryPoolId_t mp_id);




uint32_t osMemoryPoolGetCount (osMemoryPoolId_t mp_id);




uint32_t osMemoryPoolGetSpace (osMemoryPoolId_t mp_id);




osStatus_t osMemoryPoolDelete (osMemoryPoolId_t mp_id);
# 698 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/Include\\cmsis_os2.h"
osMessageQueueId_t osMessageQueueNew (uint32_t msg_count, uint32_t msg_size, const osMessageQueueAttr_t *attr);




const char *osMessageQueueGetName (osMessageQueueId_t mq_id);







osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout);







osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout);




uint32_t osMessageQueueGetCapacity (osMessageQueueId_t mq_id);




uint32_t osMessageQueueGetMsgSize (osMessageQueueId_t mq_id);




uint32_t osMessageQueueGetCount (osMessageQueueId_t mq_id);




uint32_t osMessageQueueGetSpace (osMessageQueueId_t mq_id);




osStatus_t osMessageQueueReset (osMessageQueueId_t mq_id);




osStatus_t osMessageQueueDelete (osMessageQueueId_t mq_id);
# 31 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h" 2

# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h" 1
# 27 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList\\BufList.h" 1
# 29 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList\\BufList.h"
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList/LinkList.h" 1
# 31 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList/LinkList.h"
typedef struct Link_s {
    struct Link_s *next;
    struct Link_s *prev;
} Link_t;


typedef struct {
    Link_t *head;
    Link_t *tail;
} List_t;







extern void ListInit (List_t *list);







extern void ListPut (List_t *list, Link_t *link);







void ListPutHead (List_t *list, Link_t *link);







extern Link_t *ListGet (List_t *list);







extern Link_t *ListPeekHead (List_t *list);







extern Link_t *ListPeekTail (List_t *list);







extern Link_t *ListPeekNext (Link_t *link);







extern Link_t *ListPeekPrev (Link_t *link);
# 113 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList/LinkList.h"
extern void ListInsert (List_t *list, Link_t *link, Link_t *lnew);







extern void ListRemove (List_t *list, Link_t *link);
# 30 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList\\BufList.h" 2

typedef struct {
  uint16_t wr_idx;
  uint16_t rd_idx;
  uint8_t data[];
} BUF_MEM;

typedef struct {
  List_t list;
  void *mutex;
  void *mp_id;
  uint16_t bl_sz;
  uint16_t rsvd;
} BUF_LIST;




extern int32_t BufInit (void *mp_id, void *mutex, BUF_LIST *p);




extern int32_t BufUninit (BUF_LIST *p);




extern BUF_MEM *BufAlloc (BUF_LIST *p);




extern BUF_MEM *BufFree (BUF_LIST *p);




extern BUF_MEM *BufGetTail (BUF_LIST *p);






extern uint16_t BufGetSize (BUF_LIST *p);







extern uint32_t BufGetFree (BUF_LIST *p);




extern uint32_t BufGetCount (BUF_LIST *p);






extern int32_t BufReadByte (BUF_LIST *p);






extern int32_t BufPeekByte (BUF_LIST *p);






extern int32_t BufPeekOffs (uint32_t offs, BUF_LIST *p);






extern int32_t BufFlushByte (BUF_LIST *p);




extern int32_t BufWriteByte (uint8_t data, BUF_LIST *p);
# 132 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList\\BufList.h"
extern int32_t BufRead (uint8_t *buf, uint32_t num, BUF_LIST *p);




extern int32_t BufWrite (uint8_t *buf, uint32_t num, BUF_LIST *p);






extern uint32_t BufCopy (BUF_LIST *dst, BUF_LIST *src, uint32_t num);






extern uint32_t BufFlush (uint32_t num, BUF_LIST *p);







extern int32_t BufFindByte (uint8_t data, BUF_LIST *p);
# 172 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList\\BufList.h"
extern int32_t BufFind (const uint8_t *data, uint32_t num, BUF_LIST *p);
# 186 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/BufList\\BufList.h"
extern int32_t BufCompareString (const char *string, uint32_t offs, BUF_LIST *p);
# 28 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h" 2

# 1 "./RTE/CMSIS_Driver\\WiFi_ESP8266_Config.h" 1
# 30 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h" 2
# 82 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern void AT_Notify (uint32_t event, void *arg);
# 116 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
typedef struct {
  uint8_t ecn;
  char ssid[32+1];
  int8_t rssi;
  uint8_t mac[6];
  uint8_t ch;
  uint16_t freq_offs;
} AT_DATA_CWLAP;


typedef struct {
  char *ssid;
  char *pwd;
  uint8_t ch;
  uint8_t ecn;
  uint8_t max_conn;
  uint8_t ssid_hide;
} AT_DATA_CWSAP;


typedef struct {
  char ssid[32+1];
  uint8_t bssid[6];
  uint8_t ch;
  uint8_t rssi;
} AT_DATA_CWJAP;


typedef struct {
  uint8_t link_id;
  char type[4];
  uint8_t c_s;
  uint8_t remote_ip[4];
  uint16_t remote_port;
  uint16_t local_port;
} AT_DATA_LINK_CONN;


typedef struct {
  uint32_t baudrate;
  uint8_t databits;
  uint8_t stopbits;
  uint8_t parity;
  uint8_t flow_control;
} AT_PARSER_COM_SERIAL;


typedef struct {
  BUF_LIST mem;
  BUF_LIST resp;
  uint8_t state;
  uint8_t cmd_sent;
  uint8_t gen_resp;
  uint8_t msg_code;
  uint8_t ctrl_code;
  uint8_t resp_code;
  uint8_t resp_len;
  uint8_t rsvd[2];
  uint32_t ipd_rx;
} AT_PARSER_HANDLE;
# 190 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Parser_Initialize (void);
extern int32_t AT_Parser_Uninitialize (void);
extern int32_t AT_Parser_GetSerialCfg (AT_PARSER_COM_SERIAL *info);
extern int32_t AT_Parser_SetSerialCfg (AT_PARSER_COM_SERIAL *info);
extern void AT_Parser_Execute (void);
extern void AT_Parser_Reset (void);
# 206 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_TestAT (void);
# 215 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_Reset (void);
# 224 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_GetVersion (void);
# 233 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_GetVersion (uint8_t *buf, uint32_t len);
# 245 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_Echo (uint32_t enable);
# 262 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConfigUART (uint32_t at_cmode, uint32_t baudrate, uint32_t databits, uint32_t stop_par_flowc);
# 272 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_ConfigUART (uint32_t *baudrate, uint32_t *databits, uint32_t *stop_par_flowc);
# 284 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_Sleep (uint32_t at_cmode, uint32_t sleep_mode);
# 294 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_Sleep (uint32_t *sleep_mode);
# 305 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_TxPower (uint32_t tx_power);
# 319 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_SysMessages (uint32_t n);
# 334 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_CurrentMode (uint32_t at_cmode, uint32_t mode);







extern int32_t AT_Resp_CurrentMode (uint32_t *mode);
# 356 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConnectAP (uint32_t at_cmode, const char *ssid, const char *pwd, const char *bssid);
# 368 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_ConnectAP (AT_DATA_CWJAP *ap);





extern int32_t AT_Cmd_DisconnectAP (void);
# 386 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConfigureAP (uint32_t at_cmode, AT_DATA_CWSAP *cfg);







extern int32_t AT_Resp_ConfigureAP (AT_DATA_CWSAP *cfg);







extern int32_t AT_Cmd_ListAP (void);
# 415 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_ListAP (AT_DATA_CWLAP *ap);
# 427 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_StationMAC (uint32_t at_cmode, const uint8_t mac[]);







extern int32_t AT_Resp_StationMAC (uint8_t mac[]);
# 447 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_AccessPointMAC (uint32_t at_cmode, uint8_t mac[]);







extern int32_t AT_Resp_AccessPointMAC (uint8_t mac[]);
# 469 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_StationIP (uint32_t at_cmode, uint8_t ip[], uint8_t gw[], uint8_t mask[]);
# 480 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_StationIP (uint8_t addr[]);
# 493 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_AccessPointIP (uint32_t at_cmode, uint8_t ip[], uint8_t gw[], uint8_t mask[]);
# 504 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_AccessPointIP (uint8_t addr[]);
# 516 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_DNS (uint32_t at_cmode, uint32_t enable, uint8_t dns0[], uint8_t dns1[]);
# 541 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_DNS (uint8_t addr[]);
# 554 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_DHCP (uint32_t at_cmode, uint32_t mode, uint32_t enable);
# 576 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_DHCP (uint32_t *mode);
# 589 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_RangeDHCP (uint32_t at_cmode, uint32_t en_tlease, uint8_t ip_start[], uint8_t ip_end[]);
# 602 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_RangeDHCP (uint32_t *t_lease, uint8_t ip_start[], uint8_t ip_end[]);
# 617 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_AutoConnectAP (uint32_t at_cmode, uint32_t enable);
# 627 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_AutoConnectAP (uint32_t *enable);






extern int32_t AT_Cmd_ListIP (void);
# 646 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_ListIP (uint8_t ip[], uint8_t mac[]);
# 663 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_SendData (uint32_t at_cmode, uint32_t link_id, uint32_t length, const uint8_t remote_ip[], uint16_t remote_port);
# 675 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConnectionMux (uint32_t at_cmode, uint32_t mode);
# 686 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_ConnectionMux (uint32_t *mode);
# 701 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_TcpServer (uint32_t at_cmode, uint32_t mode, uint16_t port);
# 713 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_TcpServerMaxConn (uint32_t at_cmode, uint32_t num);
# 724 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_TcpServerMaxConn (uint32_t *num);






extern int32_t AT_Cmd_RemoteInfo (uint32_t mode);
# 749 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_IPD (uint32_t *link_id, uint32_t *len, uint8_t *remote_ip, uint16_t *remote_port);
# 760 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_GetStatus (uint32_t at_cmode);
# 771 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
int32_t AT_Resp_GetStatus (AT_DATA_LINK_CONN *conn);
# 786 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_DnsFunction (uint32_t at_cmode, const char *domain);
# 797 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_DnsFunction (uint8_t ip[]);
# 815 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConnOpenTCP (uint32_t at_cmode, uint32_t link_id, const uint8_t r_ip[], uint16_t r_port, uint16_t keep_alive);
# 834 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConnOpenUDP (uint32_t at_cmode, uint32_t link_id, const uint8_t r_ip[], uint16_t r_port, uint16_t l_port, uint32_t mode);
# 849 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_ConnectionClose (uint32_t at_cmode, uint32_t link_id);
# 866 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Cmd_Ping (uint32_t at_cmode, const uint8_t ip[], const char *domain);
# 879 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_Ping (uint32_t *time);






extern int32_t AT_Resp_Generic (void);







extern int32_t AT_Resp_LinkConn (uint32_t *status, AT_DATA_LINK_CONN *conn);
# 904 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_CtrlConn (uint32_t *conn_id);







extern int32_t AT_Resp_StaMac (uint8_t mac[]);
# 922 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/ESP8266.h"
extern int32_t AT_Resp_ErrCode (uint32_t *err_code);




extern uint32_t AT_Send_GetFree (void);




extern uint32_t AT_Send_Data (const uint8_t *buf, uint32_t len);
# 33 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h" 2
# 110 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h"
typedef struct {
  BUF_LIST mem;
  int32_t type;
  int32_t protocol;
  uint32_t tout_rx;
  uint32_t tout_tx;
  volatile
  uint8_t state;
  uint8_t flags;
  uint8_t server;
  uint8_t backlog;
  volatile
  uint32_t conn_id;
  uint32_t rx_len;

  uint16_t r_port;
  uint16_t l_port;
  uint8_t r_ip[4];
  uint8_t l_ip[4];
} WIFI_SOCKET;


typedef struct {
  uint8_t st_ip[4];
  uint8_t st_gateway[4];
  uint8_t st_netmask[4];
  uint8_t st_bssid[6];

  uint8_t ap_mac[6];
  uint8_t ap_ip[4];
  uint8_t ap_gateway[4];
  uint8_t ap_netmask[4];
  uint8_t ap_dhcp_pool_start[4];
  uint8_t ap_dhcp_pool_end[4];
  uint32_t ap_dhcp_lease;
} WIFI_OPTIONS;
# 162 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.h"
typedef struct {
  ARM_WIFI_SignalEvent_t cb_event;
  osThreadId_t thread_id;
  osEventFlagsId_t evflags_id;
  osMemoryPoolId_t mempool_id;
  osMutexId_t mutex_id;
  osMutexId_t memmtx_id;
  WIFI_OPTIONS options;
  uint32_t lp_timer;
  uint8_t tx_power;
  uint8_t conn_id;
  uint8_t ap_ecn;
  char ap_pass[33];
  uint16_t packdump;
  uint16_t flags;
} WIFI_CTRL;

extern ARM_DRIVER_WIFI Driver_WiFi0;


static ARM_DRIVER_VERSION ARM_WIFI_GetVersion (void);
static ARM_WIFI_CAPABILITIES ARM_WIFI_GetCapabilities (void);
static int32_t ARM_WIFI_Initialize (ARM_WIFI_SignalEvent_t cb_event);
static int32_t ARM_WIFI_Uninitialize (void);
static int32_t ARM_WIFI_PowerControl (ARM_POWER_STATE state);
static int32_t ARM_WIFI_GetModuleInfo (char *module_info, uint32_t max_len);
static int32_t ARM_WIFI_SetOption (uint32_t interface, uint32_t option, const void *data, uint32_t len);
static int32_t ARM_WIFI_GetOption (uint32_t interface, uint32_t option, void *data, uint32_t *len);
static int32_t ARM_WIFI_Scan (ARM_WIFI_SCAN_INFO_t scan_info[], uint32_t max_num);
static int32_t ARM_WIFI_Activate (uint32_t interface, const ARM_WIFI_CONFIG_t *config);
static int32_t ARM_WIFI_Deactivate (uint32_t interface);
static uint32_t ARM_WIFI_IsConnected (void);
static int32_t ARM_WIFI_GetNetInfo (ARM_WIFI_NET_INFO_t *net_info);
static int32_t ARM_WIFI_BypassControl (uint32_t interface, uint32_t mode);
static int32_t ARM_WIFI_EthSendFrame (uint32_t interface, const uint8_t *frame, uint32_t len);
static int32_t ARM_WIFI_EthReadFrame (uint32_t interface, uint8_t *frame, uint32_t len);
static uint32_t ARM_WIFI_EthGetRxFrameSize (uint32_t interface);
static int32_t ARM_WIFI_SocketCreate (int32_t af, int32_t type, int32_t protocol);
static int32_t ARM_WIFI_SocketBind (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port);
static int32_t ARM_WIFI_SocketListen (int32_t socket, int32_t backlog);
static int32_t ARM_WIFI_SocketAccept (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
static int32_t ARM_WIFI_SocketConnect (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port);
static int32_t ARM_WIFI_SocketRecv (int32_t socket, void *buf, uint32_t len);
static int32_t ARM_WIFI_SocketRecvFrom (int32_t socket, void *buf, uint32_t len, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
static int32_t ARM_WIFI_SocketSend (int32_t socket, const void *buf, uint32_t len);
static int32_t ARM_WIFI_SocketSendTo (int32_t socket, const void *buf, uint32_t len, const uint8_t *ip, uint32_t ip_len, uint16_t port);
static int32_t ARM_WIFI_SocketGetSockName (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
static int32_t ARM_WIFI_SocketGetPeerName (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
static int32_t ARM_WIFI_SocketGetOpt (int32_t socket, int32_t opt_id, void *opt_val, uint32_t *opt_len);
static int32_t ARM_WIFI_SocketSetOpt (int32_t socket, int32_t opt_id, const void *opt_val, uint32_t opt_len);
static int32_t ARM_WIFI_SocketClose (int32_t socket);
static int32_t ARM_WIFI_SocketGetHostByName (const char *name, int32_t af, uint8_t *ip, uint32_t *ip_len);
static int32_t ARM_WIFI_Ping (const uint8_t *ip, uint32_t ip_len);


static void WiFi_Thread (void *arg) __attribute__((noreturn));
static int32_t WiFi_Wait (uint32_t event, uint32_t timeout);
static int32_t ResetModule (void);
static int32_t SetupCommunication (void);
static int32_t LoadOptions (void);
static int32_t IsUnspecifiedIP (const uint8_t ip[]);
static int32_t GetCurrentMAC (uint32_t interface, uint8_t mac[]);
static int32_t GetCurrentIpAddr (uint32_t interface, uint8_t ip[], uint8_t gw[], uint8_t mask[]);
static int32_t GetCurrentDhcpPool (uint32_t *t_lease, uint8_t ip_start[], uint8_t ip_end[]);
static int32_t GetCurrentDnsAddr (uint32_t interface, uint8_t dns0[], uint8_t dns1[]);
static uint32_t GetOpt (const void *opt_val, uint32_t opt_len);
static uint32_t SetOpt (void *opt_val, uint32_t val, uint32_t opt_len);
static uint32_t ConnId_Alloc (void);
static void ConnId_Free (uint32_t conn_id);
static void ConnId_Accept (uint32_t conn_id);
# 45 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c" 2
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h" 1
# 28 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h"
# 1 "../../../Library/CMSIS/Include\\cmsis_compiler.h" 1
# 41 "../../../Library/CMSIS/Include\\cmsis_compiler.h"
# 1 "../../../Library/CMSIS/Include/cmsis_armclang.h" 1
# 31 "../../../Library/CMSIS/Include/cmsis_armclang.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 1 3






# 1 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_acle.h" 1 3
# 39 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_acle.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__)) __wfi(void) {
  __builtin_arm_wfi();
}



static __inline__ void __attribute__((__always_inline__, __nodebug__)) __wfe(void) {
  __builtin_arm_wfe();
}



static __inline__ void __attribute__((__always_inline__, __nodebug__)) __sev(void) {
  __builtin_arm_sev();
}



static __inline__ void __attribute__((__always_inline__, __nodebug__)) __sevl(void) {
  __builtin_arm_sevl();
}



static __inline__ void __attribute__((__always_inline__, __nodebug__)) __yield(void) {
  __builtin_arm_yield();
}







static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__swp(uint32_t __x, volatile uint32_t *__p) {
  uint32_t v;
  do
    v = __builtin_arm_ldrex(__p);
  while (__builtin_arm_strex(__x, __p));
  return v;
}
# 107 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_acle.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__)) __nop(void) {
  __builtin_arm_nop();
}





static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__ror(uint32_t __x, uint32_t __y) {
  __y %= 32;
  if (__y == 0)
    return __x;
  return (__x >> __y) | (__x << (32 - __y));
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
__rorll(uint64_t __x, uint32_t __y) {
  __y %= 64;
  if (__y == 0)
    return __x;
  return (__x >> __y) | (__x << (64 - __y));
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
__rorl(unsigned long __x, uint32_t __y) {

  return __ror(__x, __y);



}



static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__clz(uint32_t __t) {
  return __builtin_clz(__t);
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
__clzl(unsigned long __t) {
  return __builtin_clzl(__t);
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
__clzll(uint64_t __t) {
  return __builtin_clzll(__t);
}


static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__cls(uint32_t __t) {
  return __builtin_arm_cls(__t);
}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__clsl(unsigned long __t) {

  return __builtin_arm_cls(__t);



}

static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__clsll(uint64_t __t) {
  return __builtin_arm_cls64(__t);
}


static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__rev(uint32_t __t) {
  return __builtin_bswap32(__t);
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
__revl(unsigned long __t) {

  return __builtin_bswap32(__t);



}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
__revll(uint64_t __t) {
  return __builtin_bswap64(__t);
}


static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__rev16(uint32_t __t) {
  return __ror(__rev(__t), 16);
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
__rev16ll(uint64_t __t) {
  return (((uint64_t)__rev16(__t >> 32)) << 32) | __rev16(__t);
}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
__rev16l(unsigned long __t) {

    return __rev16(__t);



}


static __inline__ int16_t __attribute__((__always_inline__, __nodebug__))
__revsh(int16_t __t) {
  return __builtin_bswap16(__t);
}


static __inline__ uint32_t __attribute__((__always_inline__, __nodebug__))
__rbit(uint32_t __t) {
  return __builtin_arm_rbit(__t);
}

static __inline__ uint64_t __attribute__((__always_inline__, __nodebug__))
__rbitll(uint64_t __t) {

  return (((uint64_t)__builtin_arm_rbit(__t)) << 32) |
         __builtin_arm_rbit(__t >> 32);



}

static __inline__ unsigned long __attribute__((__always_inline__, __nodebug__))
__rbitl(unsigned long __t) {

  return __rbit(__t);



}
# 8 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 2 3
# 36 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
static __inline__ unsigned int __attribute__((unavailable(
    "intrinsic not supported for this architecture"))) __disable_fiq(void);
# 65 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
__disable_irq(void) {
  unsigned int cpsr;


  __asm__ __volatile__("mrs %[cpsr], primask\n"
                       "cpsid i\n"
                       : [cpsr] "=r"(cpsr));
  return cpsr & 0x1;
# 89 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
}



static __inline__ void __attribute__((unavailable(
    "intrinsic not supported for this architecture"))) __enable_fiq(void);
# 112 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
static __inline__ void __attribute__((__always_inline__, __nodebug__))
__enable_irq(void) {

  __asm__ __volatile__("cpsie i");
# 124 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
}

static __inline__ void __attribute__((__always_inline__, __nodebug__)) __force_stores(void) {
    __asm__ __volatile__ ("" : : : "memory", "cc");
}

static void __attribute__((__always_inline__, __nodebug__)) __memory_changed(void) {
    __asm__ __volatile__ ("" : : : "memory", "cc");
}

static void __attribute__((__always_inline__, __nodebug__)) __schedule_barrier(void) {
    __asm__ __volatile__ ("" : : : "memory", "cc");
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
__semihost(int val, const void *ptr) {
  register int v __asm__("r0") = val;
  register const void *p __asm__("r1") = ptr;
  __asm__ __volatile__(


      "bkpt 0xab"
# 160 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
      : "+r"(v), "+r"(p)
      :
      : "memory", "cc");
  return v;
}
# 181 "C:\\Keil_v5\\ARM\\ARMCLANG\\Bin\\..\\include\\arm_compat.h" 3
static __inline__ unsigned int __attribute__((
    unavailable("intrinsic not supported for targets without floating point")))
__vfp_status(unsigned int mask, unsigned int flags);
# 32 "../../../Library/CMSIS/Include/cmsis_armclang.h" 2
# 63 "../../../Library/CMSIS/Include/cmsis_armclang.h"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpacked"

 struct __attribute__((packed)) T_UINT32 { uint32_t v; };
#pragma clang diagnostic pop



#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpacked"

 struct __attribute__((packed, aligned(1))) T_UINT16_WRITE { uint16_t v; };
#pragma clang diagnostic pop



#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpacked"

 struct __attribute__((packed, aligned(1))) T_UINT16_READ { uint16_t v; };
#pragma clang diagnostic pop



#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpacked"

 struct __attribute__((packed, aligned(1))) T_UINT32_WRITE { uint32_t v; };
#pragma clang diagnostic pop



#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wpacked"

 struct __attribute__((packed, aligned(1))) T_UINT32_READ { uint32_t v; };
#pragma clang diagnostic pop
# 137 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __get_CONTROL(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, control" : "=r" (result) );
  return(result);
}
# 152 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __TZ_get_CONTROL_NS(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, control_ns" : "=r" (result) );
  return(result);
}
# 167 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __set_CONTROL(uint32_t control)
{
  __asm volatile ("MSR control, %0" : : "r" (control) : "memory");
}
# 179 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __TZ_set_CONTROL_NS(uint32_t control)
{
  __asm volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
}
# 191 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __get_IPSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, ipsr" : "=r" (result) );
  return(result);
}







__attribute__((always_inline)) static __inline uint32_t __get_APSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, apsr" : "=r" (result) );
  return(result);
}







__attribute__((always_inline)) static __inline uint32_t __get_xPSR(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, xpsr" : "=r" (result) );
  return(result);
}







__attribute__((always_inline)) static __inline uint32_t __get_PSP(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, psp" : "=r" (result) );
  return(result);
}
# 248 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __TZ_get_PSP_NS(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, psp_ns" : "=r" (result) );
  return(result);
}
# 263 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __set_PSP(uint32_t topOfProcStack)
{
  __asm volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
}
# 275 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __TZ_set_PSP_NS(uint32_t topOfProcStack)
{
  __asm volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
}
# 287 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __get_MSP(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, msp" : "=r" (result) );
  return(result);
}
# 302 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __TZ_get_MSP_NS(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, msp_ns" : "=r" (result) );
  return(result);
}
# 317 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __set_MSP(uint32_t topOfMainStack)
{
  __asm volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
}
# 329 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __TZ_set_MSP_NS(uint32_t topOfMainStack)
{
  __asm volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
}
# 342 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __TZ_get_SP_NS(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, sp_ns" : "=r" (result) );
  return(result);
}







__attribute__((always_inline)) static __inline void __TZ_set_SP_NS(uint32_t topOfStack)
{
  __asm volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
}
# 368 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, primask" : "=r" (result) );
  return(result);
}
# 383 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __TZ_get_PRIMASK_NS(void)
{
  uint32_t result;

  __asm volatile ("MRS %0, primask_ns" : "=r" (result) );
  return(result);
}
# 398 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __set_PRIMASK(uint32_t priMask)
{
  __asm volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
}
# 410 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __TZ_set_PRIMASK_NS(uint32_t priMask)
{
  __asm volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
}
# 568 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __get_PSPLIM(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, psplim" : "=r" (result) );
  return(result);
}
# 599 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __set_PSPLIM(uint32_t ProcStackPtrLimit)
{
  __asm volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
}
# 624 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __get_MSPLIM(void)
{
  register uint32_t result;

  __asm volatile ("MRS %0, msplim" : "=r" (result) );

  return(result);
}
# 656 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __set_MSPLIM(uint32_t MainStackPtrLimit)
{
  __asm volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
}
# 829 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline int32_t __REVSH(int32_t value)
{
  int32_t result;

  __asm volatile ("revsh %0, %1" : "=l" (result) : "l" (value) );
  return(result);
}
# 845 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __ROR(uint32_t op1, uint32_t op2)
{
  return (op1 >> op2) | (op1 << (32U - op2));
}
# 868 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
{
  uint32_t result;






  int32_t s = (4 * 8) - 1;

  result = value;
  for (value >>= 1U; value; value >>= 1U)
  {
    result <<= 1U;
    result |= value & 1U;
    s--;
  }
  result <<= s;

  return(result);
}
# 1109 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint8_t __LDAB(volatile uint8_t *ptr)
{
  uint32_t result;

  __asm volatile ("ldab %0, %1" : "=r" (result) : "Q" (*ptr) );
  return ((uint8_t) result);
}
# 1124 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint16_t __LDAH(volatile uint16_t *ptr)
{
  uint32_t result;

  __asm volatile ("ldah %0, %1" : "=r" (result) : "Q" (*ptr) );
  return ((uint16_t) result);
}
# 1139 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline uint32_t __LDA(volatile uint32_t *ptr)
{
  uint32_t result;

  __asm volatile ("lda %0, %1" : "=r" (result) : "Q" (*ptr) );
  return(result);
}
# 1154 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __STLB(uint8_t value, volatile uint8_t *ptr)
{
  __asm volatile ("stlb %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
}
# 1166 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __STLH(uint16_t value, volatile uint16_t *ptr)
{
  __asm volatile ("stlh %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
}
# 1178 "../../../Library/CMSIS/Include/cmsis_armclang.h"
__attribute__((always_inline)) static __inline void __STL(uint32_t value, volatile uint32_t *ptr)
{
  __asm volatile ("stl %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
}
# 42 "../../../Library/CMSIS/Include\\cmsis_compiler.h" 2
# 29 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h" 2
# 1 "./RTE/_Secure\\RTE_Components.h" 1
# 30 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h" 2

# 1 "./RTE/CMSIS_Driver\\WiFi_ESP8266_Config.h" 1
# 32 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h" 2
# 56 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h"
# 1 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/RTX/Include\\rtx_os.h" 1
# 102 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/RTX/Include\\rtx_os.h"
typedef struct osRtxThread_s {
  uint8_t id;
  uint8_t state;
  uint8_t flags;
  uint8_t attr;
  const char *name;
  struct osRtxThread_s *thread_next;
  struct osRtxThread_s *thread_prev;
  struct osRtxThread_s *delay_next;
  struct osRtxThread_s *delay_prev;
  struct osRtxThread_s *thread_join;
  uint32_t delay;
  int8_t priority;
  int8_t priority_base;
  uint8_t stack_frame;
  uint8_t flags_options;
  uint32_t wait_flags;
  uint32_t thread_flags;
  struct osRtxMutex_s *mutex_list;
  void *stack_mem;
  uint32_t stack_size;
  uint32_t sp;
  uint32_t thread_addr;
  uint32_t tz_memory;



} osRtxThread_t;
# 143 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/RTX/Include\\rtx_os.h"
typedef struct {
  osTimerFunc_t func;
  void *arg;
} osRtxTimerFinfo_t;


typedef struct osRtxTimer_s {
  uint8_t id;
  uint8_t state;
  uint8_t flags;
  uint8_t type;
  const char *name;
  struct osRtxTimer_s *prev;
  struct osRtxTimer_s *next;
  uint32_t tick;
  uint32_t load;
  osRtxTimerFinfo_t finfo;
} osRtxTimer_t;





typedef struct {
  uint8_t id;
  uint8_t reserved_state;
  uint8_t flags;
  uint8_t reserved;
  const char *name;
  osRtxThread_t *thread_list;
  uint32_t event_flags;
} osRtxEventFlags_t;





typedef struct osRtxMutex_s {
  uint8_t id;
  uint8_t reserved_state;
  uint8_t flags;
  uint8_t attr;
  const char *name;
  osRtxThread_t *thread_list;
  osRtxThread_t *owner_thread;
  struct osRtxMutex_s *owner_prev;
  struct osRtxMutex_s *owner_next;
  uint8_t lock;
  uint8_t padding[3];
} osRtxMutex_t;





typedef struct {
  uint8_t id;
  uint8_t reserved_state;
  uint8_t flags;
  uint8_t reserved;
  const char *name;
  osRtxThread_t *thread_list;
  uint16_t tokens;
  uint16_t max_tokens;
} osRtxSemaphore_t;





typedef struct {
  uint32_t max_blocks;
  uint32_t used_blocks;
  uint32_t block_size;
  void *block_base;
  void *block_lim;
  void *block_free;
} osRtxMpInfo_t;


typedef struct {
  uint8_t id;
  uint8_t reserved_state;
  uint8_t flags;
  uint8_t reserved;
  const char *name;
  osRtxThread_t *thread_list;
  osRtxMpInfo_t mp_info;
} osRtxMemoryPool_t;





typedef struct osRtxMessage_s {
  uint8_t id;
  uint8_t reserved_state;
  uint8_t flags;
  uint8_t priority;
  struct osRtxMessage_s *prev;
  struct osRtxMessage_s *next;
} osRtxMessage_t;


typedef struct {
  uint8_t id;
  uint8_t reserved_state;
  uint8_t flags;
  uint8_t reserved;
  const char *name;
  osRtxThread_t *thread_list;
  osRtxMpInfo_t mp_info;
  uint32_t msg_size;
  uint32_t msg_count;
  osRtxMessage_t *msg_first;
  osRtxMessage_t *msg_last;
} osRtxMessageQueue_t;





typedef struct {
  uint8_t id;
  uint8_t state;
  uint8_t flags;
  uint8_t reserved;
  const char *name;
  osRtxThread_t *thread_list;
} osRtxObject_t;





typedef struct {
  const char *os_id;
  uint32_t version;
  struct {
    uint8_t state;
    volatile uint8_t blocked;
    uint8_t pendSV;
    uint8_t reserved;
    uint32_t tick;
  } kernel;
  int32_t tick_irqn;
  struct {
    struct {
      osRtxThread_t *curr;
      osRtxThread_t *next;
    } run;
    osRtxObject_t ready;
    osRtxThread_t *idle;
    osRtxThread_t *delay_list;
    osRtxThread_t *wait_list;
    osRtxThread_t *terminate_list;
    struct {
      osRtxThread_t *thread;
      uint32_t tick;
      uint32_t timeout;
    } robin;
  } thread;
  struct {
    osRtxTimer_t *list;
    osRtxThread_t *thread;
    osRtxMessageQueue_t *mq;
    void (*tick)(void);
  } timer;
  struct {
    uint16_t max;
    uint16_t cnt;
    uint16_t in;
    uint16_t out;
    void **data;
  } isr_queue;
  struct {
    void (*thread)(osRtxThread_t*);
    void (*event_flags)(osRtxEventFlags_t*);
    void (*semaphore)(osRtxSemaphore_t*);
    void (*memory_pool)(osRtxMemoryPool_t*);
    void (*message)(osRtxMessage_t*);
  } post_process;
  struct {
    void *stack;
    void *mp_data;
    void *mq_data;
    void *common;
  } mem;
  struct {
    osRtxMpInfo_t *stack;
    osRtxMpInfo_t *thread;
    osRtxMpInfo_t *timer;
    osRtxMpInfo_t *event_flags;
    osRtxMpInfo_t *mutex;
    osRtxMpInfo_t *semaphore;
    osRtxMpInfo_t *memory_pool;
    osRtxMpInfo_t *message_queue;
  } mpi;
} osRtxInfo_t;

extern osRtxInfo_t osRtxInfo;


typedef struct {
  uint32_t cnt_alloc;
  uint32_t cnt_free;
  uint32_t max_used;
} osRtxObjectMemUsage_t;


extern osRtxObjectMemUsage_t osRtxThreadMemUsage;
extern osRtxObjectMemUsage_t osRtxTimerMemUsage;
extern osRtxObjectMemUsage_t osRtxEventFlagsMemUsage;
extern osRtxObjectMemUsage_t osRtxMutexMemUsage;
extern osRtxObjectMemUsage_t osRtxSemaphoreMemUsage;
extern osRtxObjectMemUsage_t osRtxMemoryPoolMemUsage;
extern osRtxObjectMemUsage_t osRtxMessageQueueMemUsage;
# 402 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/RTX/Include\\rtx_os.h"
extern uint32_t osRtxErrorNotify (uint32_t code, void *object_id);


extern void osRtxIdleThread (void *argument);


extern void SVC_Handler (void);
extern void PendSV_Handler (void);
extern void SysTick_Handler (void);
# 426 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS/5.7.0/CMSIS/RTOS2/RTX/Include\\rtx_os.h"
typedef struct {
  uint32_t flags;
  uint32_t tick_freq;
  uint32_t robin_timeout;
  struct {
    void **data;
    uint16_t max;
    uint16_t padding;
  } isr_queue;
  struct {
    void *stack_addr;
    uint32_t stack_size;
    void *mp_data_addr;
    uint32_t mp_data_size;
    void *mq_data_addr;
    uint32_t mq_data_size;
    void *common_addr;
    uint32_t common_size;
  } mem;
  struct {
    osRtxMpInfo_t *stack;
    osRtxMpInfo_t *thread;
    osRtxMpInfo_t *timer;
    osRtxMpInfo_t *event_flags;
    osRtxMpInfo_t *mutex;
    osRtxMpInfo_t *semaphore;
    osRtxMpInfo_t *memory_pool;
    osRtxMpInfo_t *message_queue;
  } mpi;
  uint32_t thread_stack_size;
  const
  osThreadAttr_t *idle_thread_attr;
  const
  osThreadAttr_t *timer_thread_attr;
  const
  osMessageQueueAttr_t *timer_mq_attr;
  uint32_t timer_mq_mcnt;
} osRtxConfig_t;

extern const osRtxConfig_t osRtxConfig;
# 57 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h" 2
# 91 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266_Os.h"
extern const osThreadAttr_t WiFi_Thread_Attr;


extern const osEventFlagsAttr_t WiFi_EventFlags_Attr;


extern const osMutexAttr_t Socket_Mutex_Attr;


extern const osMemoryPoolAttr_t Socket_MemPool_Attr;


extern const osMemoryPoolAttr_t AT_Parser_MemPool_Attr;


extern const osMutexAttr_t BufList_Mutex_Attr;
# 46 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c" 2
# 56 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static WIFI_SOCKET Socket[5];


static WIFI_CTRL WIFI_Ctrl;



static const ARM_WIFI_CAPABILITIES DriverCapabilities = {
  1U,
  1U,
  1U,
  0U,
  0U,
  1U,
  1U,
  0U,
  0U,
  1U,
  0U,
  1U,
  0U
};







void AT_Notify (uint32_t event, void *arg) {
  static uint8_t rx_sock;
  static uint32_t rx_num;
  uint32_t *u32;
  uint8_t mac[6];
  int32_t ex;
  uint8_t n;
  uint32_t conn_id, len;
  uint32_t addr;
  AT_DATA_LINK_CONN conn;
  WIFI_SOCKET *sock;
  uint32_t stat;

  if (event == 0) {

    osThreadFlagsSet ((&WIFI_Ctrl)->thread_id, 0x01);
  }
  else if (event == 12) {

    osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << 3));
  }
  else if (event == 11) {

    osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << 0));
  }
  else if (event == 8) {

    u32 = (uint32_t *)arg;


    *u32 = 0U;


    rx_sock = 0xFF;
    rx_num = 0U;

    ex = AT_Resp_IPD (&conn_id, &len, 0, 0);

    if (ex == 0) {

      for (n = 0U; n < 5; n++) {
        if (Socket[n].state == 5U) {
          if (Socket[n].conn_id == conn_id) {

            break;
          }
        }
      }

      if (n != 5) {

        sock = &Socket[n];


        rx_num = BufGetFree(&sock->mem);

        if (rx_num >= (len + 2U)) {

          rx_sock = n;


          BufWrite ((uint8_t *)&len, 2U, &sock->mem);


          *u32 = len;
        }


        rx_num = len;
      }
    }
  }
  else if (event == 9) {

    u32 = (uint32_t *)arg;
    addr = *u32;


    if (rx_sock != 0xFF) {
      sock = &Socket[rx_sock];


      len = BufCopy (&sock->mem, (BUF_LIST *)addr, rx_num);
    }
    else {
      len = BufFlush (rx_num, (BUF_LIST *)addr);
    }

    rx_num -= len;


    *u32 = rx_num;

    if (rx_sock != 0xFF) {

      if (rx_num == 0U) {

        osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << ( 4 + (rx_sock))));
      }
    }
  }
  else if (event == 10) {

    osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << 1));
  }
  else if (event == 4) {

    if (((&WIFI_Ctrl)->flags & (1U << 2)) == 0U) {

      ex = AT_Resp_LinkConn (&stat, &conn);

      if (ex == 0) {

        ConnId_Accept (conn.link_id);

        if (conn.c_s == 1U) {

          for (n = 0U; n < 5; n++) {
            if (Socket[n].state == 8U) {

              sock = &Socket[n];


              do {
                n = Socket[n].backlog;

                if (Socket[n].state == 3U) {

                  Socket[n].conn_id = conn.link_id;
                  Socket[n].state = 5U;


                  Socket[n].l_port = conn.local_port;
                  Socket[n].r_port = conn.remote_port;

                  memcpy (Socket[n].r_ip, conn.remote_ip, 4);
                  break;
                }
              }
              while (Socket[n].backlog != sock->backlog);

              break;
            }
          }

          if (n != 5) {

            osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << 2));
          }
        }
        else {

          for (n = 0U; n < 5; n++) {
            if (Socket[n].state == 4U) {

              if (Socket[n].conn_id == conn.link_id) {

                Socket[n].l_port = conn.local_port;
                Socket[n].r_port = conn.remote_port;


                memcpy (Socket[n].r_ip, conn.remote_ip, 4);


                Socket[n].state = 5U;
                break;
              }
            }
          }

          if (n != 5) {

            osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << ( 9 + (n))));
          }
        }
      }
    }
    else {
      ex = AT_Resp_CtrlConn (&conn_id);

      if (ex == 0) {

        ConnId_Accept (conn_id);

        conn.link_id = (uint8_t)conn_id;


        for (n = 0U; n < 5; n++) {
          if (Socket[n].state == 4U) {

            if (Socket[n].conn_id == conn.link_id) {

              Socket[n].state = 5U;
              break;
            }
          }
        }

        if (n != 5) {

          osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << ( 9 + (n))));
        }
        else {

          for (n = 0U; n < 5; n++) {
            if (Socket[n].state == 8U) {

              sock = &Socket[n];


              do {
                n = Socket[n].backlog;

                if (Socket[n].state == 3U) {

                  Socket[n].conn_id = conn.link_id;
                  Socket[n].state = 5U;
                  break;
                }
              }
              while (Socket[n].backlog != sock->backlog);

              break;
            }
          }

          if (n != 5) {

            osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << 2));
          }
        }
      }
    }
  }
  else if (event == 5) {

    ex = AT_Resp_CtrlConn (&conn_id);

    if (ex == 0) {

      ConnId_Free (conn_id);


      for (n = 0U; n < 5; n++) {
        if (Socket[n].conn_id == conn_id) {

          Socket[n].conn_id = 5;

          if (Socket[n].backlog == 0xFF) {

            if (Socket[n].state == 6U) {

              Socket[n].state = 0U;
            } else {

              Socket[n].state = 7U;
            }
          } else {

            Socket[n].state = 3U;
          }
          break;
        }
      }

      if (n != 5) {

        osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << (14 + (n))));
      }
    }
  }
  else if (event == 6) {

    ex = AT_Resp_StaMac (mac);

    (&WIFI_Ctrl)->cb_event ((1UL << 0), mac);
  }
  else if (event == 7) {

    ex = AT_Resp_StaMac (mac);

    (&WIFI_Ctrl)->cb_event ((1UL << 1), mac);
  }
  else if (event == 1) {

    (&WIFI_Ctrl)->flags |= (1U << 5);
  }
  else if (event == 2) {

    (&WIFI_Ctrl)->flags |= (1U << 6);
  }
  else if (event == 3) {

    (&WIFI_Ctrl)->flags &= ~((1U << 5) | (1U << 6));
  }
  else if (event == 15) {

    osEventFlagsSet ((&WIFI_Ctrl)->evflags_id, (1U << 0));
  }
  else if (event == 14) {

    ex = AT_Resp_ErrCode (&stat);
  }
  else {

    if (event == 13) {
      if (arg == 0) {

        (&WIFI_Ctrl)->packdump++;
      }
      else {

        __asm volatile ("bkpt ""0");
      }
    }
  }
}
# 411 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t WiFi_Wait (uint32_t event, uint32_t timeout) {
  int32_t rval;
  uint32_t flags;

  if (timeout == 0U) {

    timeout = 0xFFFFFFFFU;
  }

  flags = osEventFlagsWait ((&WIFI_Ctrl)->evflags_id, event, 0x00000000U, timeout);

  if ((flags & 0x80000000U) == 0) {

    rval = 0;
  }
  else {
    if (flags == 0xFFFFFFFEU) {

      rval = -1;
    }
    else {

      rval = -2;
    }
  }

  return (rval);
}





void WiFi_Thread (void *arg) {
  int32_t ex;
  uint32_t flags;
  uint32_t tout;

  (void)arg;

  ex = AT_Parser_Initialize();

  if (ex < 0) {

    osThreadTerminate (osThreadGetId());
  }


  tout = (20);

  while (1) {

    flags = osThreadFlagsWait ((0x01 | 0x02 | 0x04 | 0x08| 0x10), 0x00000000U, tout);

    if ((flags & 0x80000000U) == 0) {
      if (flags & 0x08) {

        AT_Parser_Uninitialize ();


        osThreadTerminate (osThreadGetId());
      }
    }

    AT_Parser_Execute();
  }
}

static void WiFi_ThreadKick (void) {
  osThreadFlagsSet ((&WIFI_Ctrl)->thread_id, 0x10);
}







static ARM_DRIVER_VERSION ARM_WIFI_GetVersion (void) {
  ARM_DRIVER_VERSION ver = { (((1) << 8) | (1)), (((1) << 8) | (4)) };
  return (ver);
}







static ARM_WIFI_CAPABILITIES ARM_WIFI_GetCapabilities (void) {
  return (DriverCapabilities);
}
# 513 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_Initialize (ARM_WIFI_SignalEvent_t cb_event) {
  int32_t rval;
  osThreadAttr_t th_attr;
  osEventFlagsAttr_t ef_attr;
  osMutexAttr_t mtx_attr;
  osMemoryPoolAttr_t mp_attr;

  rval = 0;


  (&WIFI_Ctrl)->cb_event = cb_event;

  if (((&WIFI_Ctrl)->flags & (1U << 0)) == 0U) {

    mp_attr = Socket_MemPool_Attr;
    (&WIFI_Ctrl)->mempool_id = osMemoryPoolNew (8, 512, &mp_attr);


    ef_attr = WiFi_EventFlags_Attr;
    (&WIFI_Ctrl)->evflags_id = osEventFlagsNew (&ef_attr);


    mtx_attr = Socket_Mutex_Attr;
    (&WIFI_Ctrl)->mutex_id = osMutexNew (&mtx_attr);


    mtx_attr = BufList_Mutex_Attr;
    (&WIFI_Ctrl)->memmtx_id = osMutexNew (&mtx_attr);

    if (((&WIFI_Ctrl)->mempool_id == 0) ||
        ((&WIFI_Ctrl)->evflags_id == 0) ||
        ((&WIFI_Ctrl)->mutex_id == 0) ||
        ((&WIFI_Ctrl)->memmtx_id == 0)) {

      rval = -1;
    }

    if (rval == 0) {

      th_attr = WiFi_Thread_Attr;
      (&WIFI_Ctrl)->thread_id = osThreadNew (WiFi_Thread, 0, &th_attr);


      if (osThreadGetState((&WIFI_Ctrl)->thread_id) != osThreadBlocked) {

        rval = -1;
      }
    }

    if (rval != 0) {

      if ((&WIFI_Ctrl)->thread_id != 0) {

        osThreadFlagsSet ((&WIFI_Ctrl)->thread_id, 0x08);
      }


      if ((&WIFI_Ctrl)->mempool_id != 0) {
        (void)osMemoryPoolDelete ((&WIFI_Ctrl)->mempool_id);
      }

      if ((&WIFI_Ctrl)->evflags_id != 0) {
        (void)osEventFlagsDelete ((&WIFI_Ctrl)->evflags_id);
      }

      if ((&WIFI_Ctrl)->mutex_id != 0) {
        (void)osMutexDelete ((&WIFI_Ctrl)->mutex_id);
      }

      if ((&WIFI_Ctrl)->memmtx_id != 0) {
        (void)osMutexDelete ((&WIFI_Ctrl)->memmtx_id);
      }
    }
    else {

      (&WIFI_Ctrl)->flags = (1U << 0);
    }
  }

  return (rval);
}
# 603 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_Uninitialize (void) {
  int32_t rval;
  uint32_t flags;

  rval = 0;

  if ((&WIFI_Ctrl)->thread_id != 0) {
    flags = osThreadFlagsSet ((&WIFI_Ctrl)->thread_id, 0x08);

    if ((flags & 0x80000000U) != 0U) {

      rval = -1;
    }
  }

  if ((&WIFI_Ctrl)->evflags_id != 0) {
    if (osEventFlagsDelete ((&WIFI_Ctrl)->evflags_id) != osOK) {

      rval = -1;
    }
  }

  if ((&WIFI_Ctrl)->mutex_id != 0) {
    if (osMutexDelete ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  if ((&WIFI_Ctrl)->memmtx_id != 0) {
    if (osMutexDelete ((&WIFI_Ctrl)->memmtx_id) != osOK) {

      rval = -1;
    }
  }

  if ((&WIFI_Ctrl)->mempool_id != 0) {
    if (osMemoryPoolDelete ((&WIFI_Ctrl)->mempool_id) != osOK) {

      rval = -1;
    }
  }

  if (rval == 0) {

    (&WIFI_Ctrl)->flags = 0U;
    (&WIFI_Ctrl)->cb_event = 0;
    (&WIFI_Ctrl)->thread_id = 0;
    (&WIFI_Ctrl)->mutex_id = 0;
  }

  return (rval);
}
# 671 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_PowerControl (ARM_POWER_STATE state) {
  int32_t rval, ex;
  uint32_t n;
  osThreadId_t id;

  if ((state != ARM_POWER_OFF) && (state != ARM_POWER_FULL) && (state != ARM_POWER_LOW)) {
    rval = -5;
  }
  else {
    switch (state) {
      case ARM_POWER_OFF:
        if (((&WIFI_Ctrl)->flags & (1U << 0)) == 0U) {

          rval = -1;
        }
        else {

          (&WIFI_Ctrl)->flags &= ~(1U << 1);

          rval = 0;


          id = osMutexGetOwner((&WIFI_Ctrl)->mutex_id);

          if (id != 0) {

            if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

              if (osMutexDelete ((&WIFI_Ctrl)->mutex_id) != osOK) {

                rval = -1;
              }
              else {
                (&WIFI_Ctrl)->mutex_id = osMutexNew (&Socket_Mutex_Attr);

                if ((&WIFI_Ctrl)->mutex_id == 0) {
                  rval = -1;
                }
              }
            }
          }


          for (n = 0U; n < 5; n++) {
            Socket[n].state = 0U;
          }
        }
        break;

      case ARM_POWER_LOW:
        rval = -4;
        break;

      case ARM_POWER_FULL:
        if (((&WIFI_Ctrl)->flags & (1U << 0)) == 0) {

          rval = -1;
        }
        else if (((&WIFI_Ctrl)->flags & (1U << 1)) != 0U) {

          rval = 0;
        }
        else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

          rval = -1;
        }
        else {

          ex = SetupCommunication();

          if (ex == 0) {
            ex = ResetModule();
          }

          ex = SetupCommunication();

          if (ex == 0) {

            ex = AT_Cmd_CurrentMode (1, 3U);

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                ex = AT_Resp_Generic();
              }
            }
          }

          if (ex == 0) {

            ex = LoadOptions();
          }

          if (ex == 0) {

            ex = AT_Cmd_CurrentMode (1, 1U);

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                ex = AT_Resp_Generic();
              }
            }
          }

          if (ex == 0) {

            ex = AT_Cmd_SysMessages (3U);

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                ex = AT_Resp_Generic();

                if (ex != 0) {

                  ex = 0;

                  (&WIFI_Ctrl)->flags |= (1U << 2);
                } else {
                  (&WIFI_Ctrl)->flags &= ~(1U << 2);
                }
              }
            }
          }

          if (ex == 0) {

            ex = AT_Cmd_Sleep (1, 0U);

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                ex = AT_Resp_Generic();

                if (ex == 0) {

                  osDelay(500);
                }
              }
            }
          }

          if (ex == 0) {

            ex = AT_Cmd_ConnectionMux (1, 1U);

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                ex = AT_Resp_Generic();
              }
            }
          }

          if (ex == 0) {

            ex = AT_Cmd_Echo ((0));

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                ex = AT_Resp_Generic();
              }
            }
          }

          if (ex == 0) {

            (&WIFI_Ctrl)->flags |= (1U << 1);


            (&WIFI_Ctrl)->conn_id = 0U;

            rval = 0;
          } else {
            rval = -1;
          }

          if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

            rval = -1;
          }
        }
        break;
    }
  }

  return (rval);
}
# 892 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_GetModuleInfo (char *module_info, uint32_t max_len) {
  int32_t rval, ex;

  if ((module_info == 0) || (max_len == 0U)) {
    rval = -5;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    rval = 0;

    ex = AT_Cmd_GetVersion();

    if (ex == 0) {

      ex = WiFi_Wait ((1U << 0), (5000));

      if (ex == 0) {

        ex = AT_Resp_Generic();

        if (ex == 0) {
          ex = AT_Resp_GetVersion ((uint8_t *)module_info, max_len);


          module_info[max_len-1] = '\0';
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 947 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SetOption (uint32_t interface, uint32_t option, const void *data, uint32_t len) {
  int32_t rval, ex;
  uint32_t u32;
  uint8_t ip_0[4], ip_1[4];

  if ((interface > 1U) || (data == 0) || (len < 4U)) {
    rval = -5;
  }
  else if ((&WIFI_Ctrl)->flags == 0U) {

    rval = -1;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    rval = -1;
    ex = -1;

    switch (option) {
      default:
      case 16U:
      case 17U:
      case 18U:
      case 19U:
      case 20U:
      case 21U:
      case 22U:

        rval = -4;
        break;

      case 1U:
        if (len < 6) {
          rval = -5;
        }
        else {
          if (interface == 0) {

            memcpy ((&WIFI_Ctrl)->options.st_bssid, data, 6);
            rval = 0;
          } else {
            rval = -4;
          }
        }
        break;

      case 2U:



          u32 = *(const uint32_t *)data;


          (&WIFI_Ctrl)->tx_power = (uint8_t)u32;





          ex = AT_Cmd_TxPower (u32 * 4U);


        break;

      case 3U:
        if (interface != 0) {
          rval = -4;
        }
        else {
          u32 = *(const uint32_t *)data;

          (&WIFI_Ctrl)->lp_timer = u32;

          rval = 0;
        }
        break;

      case 4U:
        rval = -4;
        break;

      case 5U:
        rval = -4;
        break;

      case 6U:
        if (len < 6) {
          rval = -5;
        }
        else {
          if (interface == 0) {

            ex = AT_Cmd_StationMAC (1, (const uint8_t *)data);
          } else {

            memcpy ((&WIFI_Ctrl)->options.ap_mac, data, 6);
            rval = 0;
          }
        }
        break;

      case 7U:
      case 8U:
      case 9U:

        if (interface == 0) {
          if (option == 7U) { memcpy ((&WIFI_Ctrl)->options.st_ip, data, 4); }
          else if (option == 8U) { memcpy ((&WIFI_Ctrl)->options.st_netmask, data, 4); }
          else if (option == 9U) { memcpy ((&WIFI_Ctrl)->options.st_gateway, data, 4); }
        }
        else {
          if (option == 7U) { memcpy ((&WIFI_Ctrl)->options.ap_ip, data, 4); }
          else if (option == 8U) { memcpy ((&WIFI_Ctrl)->options.ap_netmask, data, 4); }
          else if (option == 9U) { memcpy ((&WIFI_Ctrl)->options.ap_gateway, data, 4); }
        }
        rval = 0;
        break;

      case 10U:
      case 11U:
        ex = GetCurrentDnsAddr (interface, ip_0, ip_1);

        if (ex == 0) {
          if (option == 10U) { memcpy (ip_0, data, 4); }
          else { memcpy (ip_1, data, 4); }

          ex = AT_Cmd_DNS (1, 1, ip_0, ip_1);
        }
        break;

      case 12U:
        u32 = *(const uint32_t *)data;

        if (interface == 0) {
          if (u32 == 0) {

            (&WIFI_Ctrl)->flags |= (1U << 7);
          } else {
            (&WIFI_Ctrl)->flags &= ~(1U << 7);
          }




          ex = AT_Cmd_DHCP (1, 1U, u32 != 0U);

        } else {
          if (u32 == 0) {

            (&WIFI_Ctrl)->flags |= (1U << 8);
          } else {

            (&WIFI_Ctrl)->flags &= ~(1U << 8);
          }
          rval = 0;
        }
        break;

      case 13U:
      case 14U:
      case 15U:
        if (interface == 0) {
          rval = -4;
        }
        else {
          if (option == 13U) {
            memcpy ((&WIFI_Ctrl)->options.ap_dhcp_pool_start, data, 4);
          }
          else if (option == 14U) {
            memcpy ((&WIFI_Ctrl)->options.ap_dhcp_pool_end, data, 4);
          }
          else {
            u32 = *(const uint32_t *)data;

            (&WIFI_Ctrl)->options.ap_dhcp_lease = u32;
          }
          rval = 0;
        }
        break;
    }

    if (ex == 0) {

      ex = WiFi_Wait ((1U << 0), (5000));

      if (ex == 0) {

        ex = AT_Resp_Generic();

        if (ex == 0) {

          rval = 0;
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 1170 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_GetOption (uint32_t interface, uint32_t option, void *data, uint32_t *len) {
  uint32_t *pu32, u32;
  uint8_t *pu8;
  int32_t rval, ex;
  uint8_t ip_0[4], ip_1[4];

  if ((interface > 1U) || (data == 0) || (*len < 4U)) {
    rval = -5;
  }
  else if ((&WIFI_Ctrl)->flags == 0U) {

    rval = -1;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    rval = -1;
    ex = -1;

    switch (option) {
      default:
      case 16U:
      case 17U:
      case 18U:
      case 19U:
      case 20U:
      case 21U:
      case 22U:

        rval = -4;
        break;

      case 1U:
        if (*len < 6U) {
          rval = -5;
        }
        else {
          if (interface == 0) {
            pu8 = (uint8_t *)data;


            memcpy (pu8, (&WIFI_Ctrl)->options.st_bssid, 6U);
            *len = 6U;


            rval = 0;
          }
          else {
            rval = -4;
          }
        }
        break;

      case 2U:
        pu32 = (uint32_t *)data;


        *pu32 = (&WIFI_Ctrl)->tx_power;
        *len = 4U;


        rval = 0;
        break;

      case 3U:
        if (interface != 0) {
          rval = -4;
        }
        else {
          pu32 = (uint32_t *)data;


          *pu32 = (&WIFI_Ctrl)->lp_timer;
          *len = 4U;


          rval = 0;
        }
        break;

      case 4U:
        rval = -4;
        break;

      case 5U:
        rval = -4;
        break;

      case 6U:
        if (*len < 6U) {
          rval = -5;
        }
        else {
          *len = 6U;

          if (interface == 0) {
            ex = AT_Cmd_StationMAC (0, 0);
          } else {
            memcpy (data, (&WIFI_Ctrl)->options.ap_mac, 6U);

            rval = 0;
          }
        }
        break;

      case 7U:
      case 8U:
      case 9U:
        if (interface == 0) {
          pu8 = (uint8_t *)data;

          if (option == 7U) { memcpy (data, (&WIFI_Ctrl)->options.st_ip, 4); }
          else if (option == 8U) { memcpy (data, (&WIFI_Ctrl)->options.st_netmask, 4); }
          else if (option == 9U) { memcpy (data, (&WIFI_Ctrl)->options.st_gateway, 4); }
        }
        else {
          pu8 = (uint8_t *)data;

          if (option == 7U) { memcpy (pu8, (&WIFI_Ctrl)->options.ap_ip, 4); }
          else if (option == 9U) { memcpy (pu8, (&WIFI_Ctrl)->options.ap_gateway, 4); }
          else { memcpy (pu8, (&WIFI_Ctrl)->options.ap_netmask, 4); }
        }

        ex = -1;
        rval = 0;
        break;

      case 10U:
      case 11U:
        *len = 4U;

        ex = GetCurrentDnsAddr (interface, ip_0, ip_1);

        if (ex == 0) {
          if (option == 10U) { memcpy (data, ip_0, 4); }
          else { memcpy (data, ip_1, 4); }


          ex = -1;
          rval = 0;
        }
        break;

      case 12U:
        *len = 4U;

        if (interface == 0) {

          ex = AT_Cmd_DHCP (0, 0U, 0U);
        } else {
          pu32 = (uint32_t *)data;

          if (((&WIFI_Ctrl)->flags & (1U << 8)) != 0U) {

            *pu32 = 0U;
          } else {

            *pu32 = 1U;
          }


          ex = -1;
          rval = 0;
        }
        break;

      case 13U:
      case 14U:
      case 15U:
        *len = 4U;

        if (interface == 0) {
          rval = -4;
        }
        else {
          if (option == 13U) {
            memcpy (data, (&WIFI_Ctrl)->options.ap_dhcp_pool_start, 4);
          }
          else if (option == 14U) {
            memcpy (data, (&WIFI_Ctrl)->options.ap_dhcp_pool_end, 4);
          }
          else {
             pu32 = (uint32_t *)data;
            *pu32 = (&WIFI_Ctrl)->options.ap_dhcp_lease;
          }


          ex = -1;
          rval = 0;
        }
        break;
    }

    if (ex == 0) {

      ex = WiFi_Wait ((1U << 0), (5000));

      if (ex == 0) {

        switch (option) {
          default:
            rval = -1;
            break;

          case 1U:

            pu8 = (uint8_t *)data;

            ex = AT_Resp_AccessPointMAC (pu8);
            break;

          case 6U:
            pu8 = (uint8_t *)data;

            if (interface == 0) {
              ex = AT_Resp_StationMAC (pu8);
            } else {
              ex = AT_Resp_AccessPointMAC (pu8);
            }
            break;

          case 12U:
            pu32 = (uint32_t *)data;

            ex = AT_Resp_DHCP (&u32);

            if (ex == 0) {






              if (interface == 0) { u32 >>= 1U; }
              else { u32 &= 1U; }


              *pu32 = u32;
            }
            break;

          case 13U:
          case 14U:
          case 15U:
            pu8 = (uint8_t *)data;
            pu32 = (uint32_t *)data;

            if (interface == 0) {
              rval = -5;
            }
            else {
              ex = AT_Resp_RangeDHCP (&u32, ip_0, ip_1);

              if (ex == 0) {
                if (option == 13U) { memcpy (pu8, ip_0, 4); }
                else if (option == 14U) { memcpy (pu8, ip_1, 4); }
                else { *pu32 = u32; }
              }
            }
            break;
        }

        if (ex == 0) {

          rval = 0;
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 1461 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_Scan (ARM_WIFI_SCAN_INFO_t scan_info[], uint32_t max_num) {
  int32_t rval, ex;
  AT_DATA_CWLAP ap;
  uint32_t i;
  uint8_t ecn;

  if ((scan_info == 0) || (max_num == 0U)) {
    rval = -5;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    i = 0U;

    ex = AT_Cmd_ListAP();

    if (ex == 0) {

      ex = WiFi_Wait ((1U << 0), 5*(5000));

      if (ex == 0) {

        do {

          ex = AT_Resp_ListAP (&ap);

          if (ex >= 0) {

            if (i < max_num) {

              strcpy (scan_info[i].ssid, ap.ssid);
              memcpy (scan_info[i].bssid, ap.mac, 6);


              switch (ap.ecn) {
                case 0: ecn = 0U; break;
                case 1: ecn = 1U; break;
                case 2: ecn = 2U; break;
                case 3:
                case 4: ecn = 3U; break;
                default:
                case 5: ecn = 255U; break;
              }

              scan_info[i].security = ecn;
              scan_info[i].ch = ap.ch;
              scan_info[i].rssi = (uint8_t)ap.rssi;

              i++;
            }
          }
        }
        while (ex > 0);
      }
    }

    if (ex == 0) {

      rval = (int32_t)i;
    } else {
      rval = -1;
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 1548 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_Activate (uint32_t interface, const ARM_WIFI_CONFIG_t *config) {
  int32_t ex, rval, state;
  uint32_t mode;
  AT_DATA_CWSAP ap_cfg;
  uint8_t *ip_0, *ip_1, *ip_2;

  if ((interface > 1U) || (config == 0)) {
    rval = -5;
  }
  else if (config->wps_method != 0U) {
    rval = -4;
  }
  else if ((config->ssid == 0) || (config->pass == 0)) {
    rval = -5;
  }
  else if (config->security == 255U) {
    rval = -5;
  }
  else if (config->ch == 255U) {
    rval = -5;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    rval = -1;

    ex = -1;

    if (interface == 0) {


      memcpy ((&WIFI_Ctrl)->ap_pass, config->pass, 33);


      (&WIFI_Ctrl)->ap_ecn = config->security;

      if (((&WIFI_Ctrl)->flags & (1U << 7)) != 0) {

        state = 0U;
      }
      else {

        state = 1U;
      }


      ex = AT_Cmd_DHCP (1, 1U, state);

      if (ex == 0) {

        ex = WiFi_Wait ((1U << 0), (5000));

        if (ex == 0) {

          ex = AT_Resp_Generic();

          if (ex != 0) {
            state = 2U;
          }
        }
      }

      do {
        switch(state) {
          case 0:

            ip_0 = (&WIFI_Ctrl)->options.st_ip;
            ip_1 = (&WIFI_Ctrl)->options.st_gateway;
            ip_2 = (&WIFI_Ctrl)->options.st_netmask;

            ex = AT_Cmd_StationIP (1, ip_0, ip_1, ip_2);
            break;

          case 1:

            ex = AT_Cmd_ConnectAP (1, config->ssid, config->pass, 0);
            break;
        }

        if (ex != 0) {

          break;
        }
        else {

          ex = WiFi_Wait ((1U << 0), 10*(5000));

          if (ex == 0) {

            ex = AT_Resp_Generic();

            if ((ex != 0) && (state == 1)) {

              ex = AT_Resp_ConnectAP (0);

              if (ex == 1) {

                rval = -3;
              }
              else if (ex == 2) {

                rval = -1;
              }
              else if (ex == 3) {


                rval = -1;
              }
              else {

                rval = -1;
              }
            }
          }
        }

        state++;
      }
      while (state < 2);

      if (ex == 0) {
        (&WIFI_Ctrl)->flags |= (1U << 4);


        ex = AT_Cmd_AutoConnectAP (0, 0U);

        if (ex == 0) {

          ex = WiFi_Wait ((1U << 0), (5000));

          if (ex == 0) {

            ex = AT_Resp_Generic();

            if (ex == 0) {

              ex = AT_Resp_AutoConnectAP (&mode);

              if (ex == 0) {
                if (mode != 0U) {

                  ex = AT_Cmd_AutoConnectAP(1, 0U);

                  if (ex == 0) {

                    ex = WiFi_Wait ((1U << 0), (5000));

                    if (ex == 0) {

                      ex = AT_Resp_Generic();
                    }
                  }
                }
              }
            }
          }
        }

        if (ex == 0) {
          if (((&WIFI_Ctrl)->flags & (1U << 7)) == 0) {

            ex = GetCurrentIpAddr (0, (&WIFI_Ctrl)->options.st_ip,
                                                           (&WIFI_Ctrl)->options.st_gateway,
                                                           (&WIFI_Ctrl)->options.st_netmask);
          }
        }
      }
    }
    else {
      if (config->security == 1U) {

        rval = -4;
      }
      else {
        state = 0;

        do {
          switch (state) {
            case 0:

              if (((&WIFI_Ctrl)->flags & (1U << 4)) == 0) {

                mode = 2U;
              } else {

                mode = 3U;
              }

              ex = AT_Cmd_CurrentMode(1, mode);
              break;

            case 1:

              ap_cfg.ssid = (char *)(uint32_t)config->ssid;
              ap_cfg.pwd = (char *)(uint32_t)config->pass;

              if (config->ch != 0) {

                ap_cfg.ch = config->ch;
              } else {

                ap_cfg.ch = (2);
              }

              ap_cfg.ecn = config->security;


              ap_cfg.max_conn = 8;
              ap_cfg.ssid_hide = 0;

              ex = AT_Cmd_ConfigureAP (1, &ap_cfg);
              break;

            case 2:

              ex = AT_Cmd_AccessPointMAC (1, (&WIFI_Ctrl)->options.ap_mac);
              break;

            case 3:

              ip_0 = (&WIFI_Ctrl)->options.ap_ip;
              ip_1 = (&WIFI_Ctrl)->options.ap_gateway;
              ip_2 = (&WIFI_Ctrl)->options.ap_netmask;

              ex = AT_Cmd_AccessPointIP (1, ip_0, ip_1, ip_2);
              break;

            case 4:

              if (((&WIFI_Ctrl)->flags & (1U << 8)) == 0U) {

                mode = 1U;
              } else {

                mode = 0U;
              }




              ex = AT_Cmd_DHCP (1, 0U, mode);

              break;

            case 5:
              if (((&WIFI_Ctrl)->flags & (1U << 8)) == 0U) {

                mode = (&WIFI_Ctrl)->options.ap_dhcp_lease;
                if (mode > 2880) {

                  mode = 2880;
                }
                mode |= (1U << 16);

                ip_0 = (&WIFI_Ctrl)->options.ap_dhcp_pool_start;
                ip_1 = (&WIFI_Ctrl)->options.ap_dhcp_pool_end;
              }
              else {

                mode = 0;
                ip_0 = 0;
                ip_1 = 0;
              }



              ex = AT_Cmd_RangeDHCP (1, mode, ip_0, ip_1);
              break;
          }


          if (ex == 0) {

            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex == 0) {

              ex = AT_Resp_Generic();
            }
          }


          state++;
        }
        while (state < 6);
      }
    }

    if (ex == 0) {

      rval = 0;
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 1862 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_Deactivate (uint32_t interface) {
  int32_t rval, ex;

  if (interface > 1U) {
    rval = -5;
  }
  else if ((&WIFI_Ctrl)->flags == 0U) {

    rval = -1;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    if (interface == 0) {

      ex = AT_Cmd_DisconnectAP();

      if (ex == 0) {

        ex = WiFi_Wait ((1U << 0), (5000));

        if (ex == 0) {

          ex = AT_Resp_Generic();

          if (ex == 0) {

            (&WIFI_Ctrl)->flags &= ~(1U << 4);
          }
        }
      }
    }
    else {


      ex = AT_Cmd_CurrentMode(1, 1U);

      if (ex == 0) {

        ex = WiFi_Wait ((1U << 0), (5000));

        if (ex == 0) {

          ex = AT_Resp_Generic();

          if (ex == 0) {

            (&WIFI_Ctrl)->flags &= ~(1U << 3);
          }
        }
      }
    }

    if (ex == 0) {
      rval = 0;
    } else {
      rval = -1;
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 1940 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static uint32_t ARM_WIFI_IsConnected (void) {
  uint32_t conn;
  uint32_t flags;

  flags = (&WIFI_Ctrl)->flags & ((1U << 4) | (1U << 5));

  if (flags == ((1U << 4) | (1U << 5))) {
    conn = 1U;
  } else {
    conn = 0U;
  }

  return (conn);
}
# 1966 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_GetNetInfo (ARM_WIFI_NET_INFO_t *net_info) {
  int32_t ex, rval;
  AT_DATA_CWJAP ap;

  if (net_info == 0) {
    rval = -5;
  }
  else if ((&WIFI_Ctrl)->flags == 0U) {

    rval = -1;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    ex = AT_Cmd_ConnectAP(0, 0, 0, 0);

    if (ex == 0) {

      ex = WiFi_Wait ((1U << 0), (5000));

      if (ex == 0) {

        ex = AT_Resp_ConnectAP (&ap);

        if (ex == 0) {

          ap.ssid[32] = '\0';

          strcpy (net_info->ssid, ap.ssid);


          (&WIFI_Ctrl)->ap_pass[32] = '\0';
          strcpy (net_info->pass, (&WIFI_Ctrl)->ap_pass);


          net_info->security = (&WIFI_Ctrl)->ap_ecn;


          net_info->ch = ap.ch;


          net_info->rssi = ap.rssi;
        }
      }
    }

    if (ex == 0) {
      rval = 0;
    } else {
      rval = -1;
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}
# 2043 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_BypassControl (uint32_t interface, uint32_t mode) {
  (void)interface;
  (void)mode;
  return -4;
}
# 2063 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_EthSendFrame (uint32_t interface, const uint8_t *frame, uint32_t len) {
  (void)interface;
  (void)frame;
  (void)len;
  return -4;
}
# 2083 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_EthReadFrame (uint32_t interface, uint8_t *frame, uint32_t len) {
  (void)interface;
  (void)frame;
  (void)len;
  return -4;
}
# 2097 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static uint32_t ARM_WIFI_EthGetRxFrameSize (uint32_t interface) {
  (void)interface;
  return 0U;
}
# 2116 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketCreate (int32_t af, int32_t type, int32_t protocol) {
  int32_t rval;
  int32_t n;

  rval = 0;


  if (af != 1) {
    if (af == 2) {

      rval = (-4);
    } else {
      rval = (-3);
    }
  }
  else {

    if (type == 1) {

      if (protocol == 0U) {

        protocol = 1;
      }
      else {
        if (protocol != 1) {
          rval = (-3);
        }
      }
    }
    else if (type == 2) {

      if (protocol == 0U) {

        protocol = 2;
      }
      else {
        if (protocol != 2) {
          rval = (-3);
        }
      }
    }
    else {
      rval = (-3);
    }
  }

  if (rval == 0) {
    if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

      rval = (-1);
    }
    else {

      for (n = 0U; n < 5; n++) {
        if (Socket[n].state == 0U) {

          memset (&Socket[n], 0x00, sizeof(WIFI_SOCKET));


          Socket[n].state = 1U;


          Socket[n].type = type;
          Socket[n].protocol = protocol;
          Socket[n].server = 0xFF;
          Socket[n].backlog = 0xFF;
          Socket[n].conn_id = 5;

          Socket[n].tout_rx = 0U;
          Socket[n].tout_tx = 0U;


          BufInit ((&WIFI_Ctrl)->mempool_id, (&WIFI_Ctrl)->memmtx_id, &Socket[n].mem);
          break;
        }
      }

      if (n == 5) {

        rval = (-5);
      }
      else {

        rval = n;
      }

      if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

        rval = (-1);
      }
    }
  }

  return (rval);
}
# 2227 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketBind (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port) {
  int32_t rval;
  uint32_t n;
  uint32_t i;
  WIFI_SOCKET *sock;
  const uint8_t *ip_addr = ip;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((ip == 0) || ((ip_len != 4U) && (ip_len != 16U))) {

    rval = (-3);
  }
  else if (port == 0U) {

    rval = (-3);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->state == 0U) {

      rval = (-2);
    }
    else if (sock->state == 5U) {

      rval = (-9);
    }
    else if (sock->state == 2U) {

      rval = (-3);
    }
    else {

      for (n = 0; n < 5; n++) {
        if (Socket[n].state >= 2U) {
          if (Socket[n].l_port == port) {

            break;
          }
        }
      }

      if (n != 5) {

        rval = (-15);
      }
      else {

        for (i = 0U; i < ip_len; i++) {
          sock->l_ip[i] = ip_addr[i];
        }


        sock->l_port = port;
        sock->state = 2U;
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 2317 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketListen (int32_t socket, int32_t backlog) {
  int32_t ex, rval;
  uint8_t n;
  WIFI_SOCKET *sock;
  int32_t p, cnt;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((backlog <= 0) || (backlog >= 5)) {

    rval = (-3);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {

    sock = &Socket[socket];

    if (sock->type != 1) {

      rval = (-4);
    }
    else if (sock->state == 0U) {

      rval = (-2);
    }
    else if (sock->state == 8U) {

      rval = (-3);
    }
    else if (sock->state != 2U) {

      rval = (-3);
    }
    else {

      cnt = 0U;


      for (n = 0U; n < 5; n++) {
        if (Socket[n].state == 0U) {
          cnt++;
        }
      }

      if (cnt < backlog) {

        rval = (-4);
      }
      else {



        ex = AT_Cmd_TcpServerMaxConn (1, (uint32_t)backlog);

        if (ex == 0) {

          ex = WiFi_Wait ((1U << 0), (5000));

          if (ex == 0) {

            ex = AT_Resp_Generic();
          }
        }

        if (ex == 0) {

          ex = AT_Cmd_TcpServer (1, 1U, sock->l_port);

          if (ex == 0) {

            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex == 0) {

              ex = AT_Resp_Generic();
            }
          }
        }

        if (ex != 0) {

          rval = (-1);
        }
        else {

          sock->state = 8U;


          cnt = backlog;
          p = socket;

          for (n = 0U; n < 5; n++) {
            if (Socket[n].state == 0U) {

              Socket[p].backlog = n;


              memcpy (&Socket[n], sock, sizeof(WIFI_SOCKET));


              Socket[n].state = 3U;


              Socket[n].server = (uint8_t)socket;
              Socket[n].backlog = sock->backlog;

              p = n;

              cnt--;
              if (cnt == 0) {
                break;
              }
            }
          }
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 2471 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketAccept (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port) {
  int32_t ex, rval;
  int32_t n;
  WIFI_SOCKET *sock;
  AT_DATA_LINK_CONN conn;

  WiFi_ThreadKick();

  rval = (-1);

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((ip != 0) && (ip_len == 0)) {

    rval = (-3);
  }
  else if ((ip == 0) && (ip_len != 0)) {

    rval = (-3);
  }
  else if ((ip != 0) && (ip_len != 0) && (*ip_len < 4U)) {

    rval = (-3);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->type == 2) {

      rval = (-4);
    }
    else if (sock->state != 8U) {

      rval = (-2);
    }
    else {
      do {

        n = sock->backlog;

        if (Socket[n].state == 5U) {

          if (((&WIFI_Ctrl)->flags & (1U << 2)) != 0U) {

            ex = AT_Cmd_GetStatus (2);

            if (ex == 0) {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex == 0) {

                do {

                  ex = AT_Resp_GetStatus (&conn);

                  if (ex >= 0) {

                    if (conn.link_id == Socket[n].conn_id) {

                      memcpy (Socket[n].r_ip, conn.remote_ip, 4);

                      Socket[n].r_port = conn.remote_port;

                      Socket[n].l_port = conn.local_port;
                    }
                  }
                }
                while (ex > 0);
              }
            }
          }

          if (ip != 0) {

            *ip_len = 4U;
            memcpy (ip, Socket[n].r_ip, 4);
          }

          if (port != 0) {

            *port = Socket[n].r_port;
          }


          rval = n;


          while (Socket[n].backlog != sock->backlog) {
            n = Socket[n].backlog;
          }
          Socket[n].backlog = (uint8_t)rval;
          Socket[rval].backlog = sock->backlog;
        }
        else {

          if (sock->flags & (1U << 0)) {
            rval = (-6);
          }
          else {

            ex = WiFi_Wait ((1U << 2), (0));

            if (ex != 0) {
              if (ex == -1) {

                rval = (-6);
              }
              else if (ex == -2) {

                rval = (-1);
              }
              break;
            }
          }
        }
      }
      while (rval == (-1));
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 2627 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketConnect (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port) {
  int32_t ex, rval;
  WIFI_SOCKET *sock;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((ip == 0) || ((ip_len != 4U) && (ip_len != 16U))) {
    rval = (-3);
  }
  else if (port == 0U) {

    rval = (-3);
  }
  else if (ip_len != 4U) {

    rval = (-4);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];


    switch (sock->state) {
      case 0U:
        rval = (-2);
        break;

      case 3U:
      case 8U:

        rval = (-3);
        break;

      case 1U:
      case 2U:
        break;

      case 4U:

        rval = (-14);
        break;

      case 5U:

        rval = (-9);
        break;

      case 7U:

        rval = (-8);
        break;

      default:
        rval = (-1);
        break;
    }

    if (rval == 0) {

      memcpy (sock->r_ip, ip, 4);
      sock->r_port = port;

      if (sock->type == 2) {

        sock->state = 2U;
      }
      else {
        if (IsUnspecifiedIP (ip) != 0U) {

          rval = (-3);
        }
        else {

          sock->state = 4U;


          sock->conn_id = ConnId_Alloc();


          ex = AT_Cmd_ConnOpenTCP (1, sock->conn_id, sock->r_ip, sock->r_port, 0U);

          if (ex != 0) {

            rval = (-1);
          }
          else {

            ex = WiFi_Wait ((1U << 0), (20000));

            if (ex == 0) {

              ex = AT_Resp_Generic();

              if (ex == 0) {
                rval = 0;
              }
              else if (ex == 7) {
                rval = (-14);
              }
              else {
                if (ex == 1) {
                  rval = (-8);
                }
              }
            }
            else {
              rval = (-1);
            }
          }
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 2773 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketRecv (int32_t socket, void *buf, uint32_t len) {
  int32_t rval;

  rval = ARM_WIFI_SocketRecvFrom (socket, buf, len, 0, 0, 0);

  return (rval);
}
# 2803 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketRecvFrom (int32_t socket, void *buf, uint32_t len, uint8_t *ip, uint32_t *ip_len, uint16_t *port) {
  int32_t ex, rval;
  WIFI_SOCKET *sock;
  uint8_t *pu8 = (uint8_t *)buf;
  uint32_t n, cnt, num;

  WiFi_ThreadKick();

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((buf == 0) && (len != 0U)) {

    rval = (-3);
  }
  else if ((ip != 0) && (*ip_len < 4U)) {

    rval = (-3);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];


    switch (sock->state) {
      case 0U:
        rval = (-2);
        break;

      case 6U:
        rval = (-3);
        break;

      case 2U:

        if (sock->type != 2) {

          rval = (-10);
        }
        break;

      case 8U:
      case 1U:
      case 4U:

        rval = (-10);
        break;

      case 5U:

        break;

      case 7U:

        if (BufGetCount(&sock->mem) > 0) {
          break;
        }
        else {
          rval = (-12);
        }
        break;

      case 3U:

        if (BufGetCount(&sock->mem) > 0) {
          break;
        }
        else {
          rval = (-10);
        }
        break;

      default:
        rval = (-1);
        break;
    }

    if (rval == 0) {
      if (sock->type == 2) {

        if (ip != 0) {
          memcpy (ip, sock->r_ip, 4); *ip_len = 4U;
        }
        if (port != 0) {
          *port = sock->r_port;
        }

        if (sock->state == 2U) {

          sock->state = 4U;


          sock->conn_id = ConnId_Alloc();


          ex = AT_Cmd_ConnOpenUDP (1, sock->conn_id, sock->r_ip,
                                                                sock->r_port,
                                                                sock->l_port,
                                                                0U);
          if (ex != 0) {

            rval = (-1);
          }
          else {

            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex != 0) {

              rval = (-1);
            }
            else {

              ex = AT_Resp_Generic();

              if (ex == 0) {
                rval = 0;
              }
              else if (ex == 7) {
                rval = (-14);
              }
              else {
                rval = (-1);
              }
            }
          }
        }
      }
    }


    n = 0;

    while (rval == 0) {

      if (sock->rx_len == 0) {

        if (BufGetCount (&sock->mem) >= 2U) {

          if (BufRead ((uint8_t *)&sock->rx_len, 2U, &sock->mem) != 2U) {

            rval = (-1);
          }
        }
      }

      if (sock->rx_len == 0) {

        if (sock->flags & (1U << 0)) {
          if (n != 0U) {

            rval = (int32_t)n;
          }
          else {

            rval = (-6);
          }
        }
        else {
          if (n != 0U) {

            rval = (int32_t)n;
          }
          else {

            osMutexRelease ((&WIFI_Ctrl)->mutex_id);

            ex = WiFi_Wait((1U << ( 4 + (socket))) | (1U << (14 + (socket))), sock->tout_rx);

            osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU);

            if (ex != 0) {
              if (ex == -1) {

                rval = (-6);
              }
              else {
                rval = (-1);
              }
            }

            if (sock->state != 5U) {
              rval = (-12);
            }
          }
        }
      }
      else if ((sock->rx_len != 0) && (len == 0)) {
        break;
      }
      else {

        if (sock->type == 2) {


          if (len < sock->rx_len) {
            cnt = len;
          } else {
            cnt = sock->rx_len;
          }


          num = cnt - n;

          n += (uint32_t)BufRead (&pu8[n], num, &sock->mem);

          if (n != cnt) {

          }
          else {

            if (n < sock->rx_len) {
              BufFlush (sock->rx_len - n, &sock->mem);
            }

            sock->rx_len = 0U;


            rval = (int32_t)n;
          }
        }
        else {


          cnt = len - n;

          if (cnt > sock->rx_len) {
            cnt = sock->rx_len;
          }

          cnt = (uint32_t)BufRead (&pu8[n], cnt, &sock->mem);

          sock->rx_len -= cnt;
          n += cnt;

          if (n == len) {

            rval = (int32_t)n;
          }
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 3078 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketSend (int32_t socket, const void *buf, uint32_t len) {
  int32_t rval;

  rval = ARM_WIFI_SocketSendTo (socket, buf, len, 0, 0U, 0U);

  return (rval);
}
# 3106 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketSendTo (int32_t socket, const void *buf, uint32_t len, const uint8_t *ip, uint32_t ip_len, uint16_t port) {
  int32_t ex, rval;
  uint32_t num, cnt, n;
  WIFI_SOCKET *sock;
  const uint8_t *pu8 = (const uint8_t *)buf;
  const uint8_t *r_ip = 0;
  uint16_t r_port = 0U;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((buf == 0) && (len != 0U)) {

    rval = (-3);
  }
  else if ((ip != 0) && (ip_len > 4)) {

    rval = (-4);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->state == 0U) {

      rval = (-2);
    }
    else {
      if (sock->type == 1) {



        switch (sock->state) {
          case 0U:
            rval = (-2);
            break;

          case 1U:
          case 2U:
          case 3U:
          case 4U:
          case 6U:
          case 8U:

            rval = (-10);
            break;

          case 5U:

            break;

          case 7U:

            rval = (-12);
            break;

          default:
            rval = (-1);
            break;
        }

        if (rval == 0) {
          r_ip = 0;
          r_port = 0U;
        }
      }
      else {

        if (ip != 0) {

          if (ip_len != 4U) {
            rval = (-3);
          }
          else if (IsUnspecifiedIP (ip) != 0U) {

            rval = (-3);
          }
          else if (port == 0) {

            rval = (-3);
          }
          else {

            r_ip = ip;
            r_port = port;
          }
        }
        else {


          r_ip = sock->r_ip;
          r_port = sock->r_port;

          if (sock->state != 5U) {

            if (sock->state != 2U) {

              rval = (-10);
            }
          }
        }

        if (len >= 2048) {


          rval = (-5);
        }

        if (len > AT_Send_GetFree()) {

          if (sock->flags & (1U << 0)) {

            rval = (-6);
          }
        }

        if (rval == 0) {
          if (sock->state != 5U) {

            sock->conn_id = ConnId_Alloc();

            sock->state = 4U;


            ex = AT_Cmd_ConnOpenUDP (1, sock->conn_id, r_ip,
                                                                  r_port,
                                                                  sock->l_port,
                                                                  0U);
            if (ex != 0) {

              rval = (-1);
            }
            else {

              ex = WiFi_Wait ((1U << 0), (5000));

              if (ex != 0) {

                rval = (-1);
              }
              else {

                ex = AT_Resp_Generic();

                if (ex == 0) {
                  rval = 0;
                }
                else if (ex == 7) {
                  rval = (-14);
                }
                else {
                  rval = (-1);
                }
              }
            }
          }
        }
      }
    }

    if (rval == 0) {
      if (sock->type == 2) {



        if (len != 0) {

          ex = AT_Cmd_SendData (1, sock->conn_id, len, r_ip, r_port);

          if (ex == 0) {

            ex = WiFi_Wait ((1U << 0), (5000));
          }

          if (ex == 0) {

            ex = WiFi_Wait ((1U << 1), (5000));
          }

          if (ex != 0) {

            rval = (-1);
          }
          else {


            num = 0U;

            while (num < len) {

              cnt = AT_Send_GetFree();

              if (cnt == 0U) {

                ex = WiFi_Wait ((1U << 3), (5000));

                if (ex == 0) {

                  cnt = AT_Send_GetFree();
                }
                else {

                  rval = (-1);
                  break;
                }
              }

              if (cnt > (len - num)) {
                cnt = (len - num);
              }

              osEventFlagsClear ((&WIFI_Ctrl)->evflags_id, (1U << 3));

              num += AT_Send_Data (&pu8[num], cnt);
            }


            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex == 0) {

              ex = AT_Resp_Generic();

              if (ex == 3) {

                rval = (int32_t)num;
              }
              else if (ex == 4) {

                rval = (-1);
              }
              else {

                rval = (-1);
              }
            }
            else {

              rval = (-1);
            }
          }
        }
      }
      else {





        num = 0U;

        while (rval == 0) {
          if ((len == 0) && (AT_Send_GetFree() != 0)) {
            break;
          }

          else if (sock->flags & (1U << 0)) {

            cnt = AT_Send_GetFree();
          }
          else {

            cnt = 2048;
          }

          if (cnt > len) {
            cnt = len;
          }


          ex = AT_Cmd_SendData (1, sock->conn_id, cnt, r_ip, r_port);

          if (ex == 0) {

            ex = WiFi_Wait ((1U << 0), (5000));
          }

          if (ex == 0) {

            ex = WiFi_Wait ((1U << 1), (5000));
          }

          if (ex != 0) {

            rval = (-1);
          }
          else {

            while (cnt != 0) {

              n = AT_Send_GetFree();

              if (n == 0U) {

                ex = WiFi_Wait ((1U << 3), (5000));

                if (ex == 0) {

                  n = AT_Send_GetFree();
                }
                else {

                  rval = (-1);
                  break;
                }
              }

              if (n > cnt) {
                n = cnt;
              }

              osEventFlagsClear ((&WIFI_Ctrl)->evflags_id, (1U << 3));

              n = AT_Send_Data (&pu8[num], n);

              num += n;
              cnt -= n;
            }


            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex == 0) {

              ex = AT_Resp_Generic();

              if (ex == 3) {

                if (sock->flags & (1U << 0)) {
                  rval = (int32_t)num;
                }
                else {
                  if (num == len) {
                    rval = (int32_t)num;
                  }
                }
              }
              else if (ex == 4) {

                rval = (-1);
              }
              else {

                rval = (-1);
              }
            }
            else {

              rval = (-1);
            }
          }
        }
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 3492 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketGetSockName (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port) {
  int32_t ex, rval;
  WIFI_SOCKET *sock;
  AT_DATA_LINK_CONN conn;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((ip != 0) && (ip_len == 0)) {

    rval = (-3);
  }
  else if ((ip_len != 0) && (*ip_len < 4U)) {

    rval = (-3);
  }
  else if ((ip != 0) && (*ip_len >= 16U)) {

    rval = (-4);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->state == 0U) {
      rval = (-2);
    }
    else if (sock->state < 2U) {
      rval = (-3);
    }
    else {
      if (sock->type == 2) {
        if (sock->state == 2U) {

          sock->state = 4U;


          sock->conn_id = ConnId_Alloc();


          ex = AT_Cmd_ConnOpenUDP (1, sock->conn_id, sock->r_ip,
                                                                sock->r_port,
                                                                sock->l_port,
                                                                0U);
          if (ex != 0) {

            rval = (-1);
          }
          else {

            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex != 0) {

              rval = (-1);
            }
            else {

              ex = AT_Resp_Generic();

              if (ex == 0) {
                rval = 0;
              }
              else if (ex == 7) {
                rval = (-14);
              }
              else {
                rval = (-1);
              }
            }
          }
        }
      }

      if (sock->state == 5U) {

        if (((&WIFI_Ctrl)->flags & (1U << 2)) != 0U) {

          ex = AT_Cmd_GetStatus (2);

          if (ex == 0) {

            ex = WiFi_Wait ((1U << 0), (5000));

            if (ex == 0) {

              do {

                ex = AT_Resp_GetStatus (&conn);

                if (ex >= 0) {

                  if (conn.link_id == sock->conn_id) {

                    memcpy (sock->r_ip, conn.remote_ip, 4);

                    sock->r_port = conn.remote_port;

                    sock->l_port = conn.local_port;
                  }
                }
              }
              while (ex > 0);
            }
          }
        }
      }

      if (ip != 0) {

        *ip_len = 4U;


        memcpy (ip, sock->l_ip, 4U);
      }
      if (port != 0) {

        *port = sock->l_port;
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 3645 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketGetPeerName (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port) {
  int32_t rval;
  WIFI_SOCKET *sock;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((ip == 0) && (ip_len != 0)) {

    rval = (-3);
  }
  else if ((ip != 0) && (*ip_len < 4U)) {

    rval = (-3);
  }
  else if ((ip != 0) && (*ip_len >= 16U)) {

    rval = (-4);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->type == 1) {
      if (sock->state == 0U) {
        rval = (-2);
      }
      else {

        if (sock->state != 5U) {

          rval = (-10);
        }
      }
    }
    else {

      if (sock->state == 0U) {
        rval = (-2);
      }
      else if (sock->state != 2U) {
        rval = (-10);
      }
      else if (sock->r_port == 0) {

        rval = (-10);
      }
      else if (IsUnspecifiedIP (sock->r_ip) != 0U) {

        rval = (-10);
      }
    }

    if (rval == 0) {

      if (ip != 0) {

        *ip_len = 4;


        memcpy (ip, sock->r_ip, 4);
      }

      if (port != 0) {

        *port = sock->r_port;
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 3746 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketGetOpt (int32_t socket, int32_t opt_id, void *opt_val, uint32_t *opt_len) {
  int32_t rval;
  WIFI_SOCKET *sock;
  uint32_t val;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((opt_val == 0) || (opt_len == 0) || (*opt_len < 4U)) {
    rval = (-3);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->state == 0U) {

      rval = (-2);
    }
    else {
      val = 0U;

      switch (opt_id) {
        case 1:

          rval = (-3);
          break;

        case 2:

          val = sock->tout_rx;
          break;

        case 3:

          val = sock->tout_tx;
          break;

        case 4:
          if ((sock->flags & (1U << 1)) != 0) {

            val = 1U;
          } else {

            val = 0U;
          }
          break;

        case 5:

          val = (uint32_t)sock->type;
          break;

        default:
          rval = (-3);
          break;
      }

      if (rval == 0) {
        *opt_len = SetOpt (opt_val, val, 4);
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 3839 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketSetOpt (int32_t socket, int32_t opt_id, const void *opt_val, uint32_t opt_len) {
  int32_t rval;
  WIFI_SOCKET *sock;
  uint32_t val;

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if ((opt_val == 0) || (opt_len == 0) || (opt_len != 4U)) {
    rval = (-3);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    sock = &Socket[socket];

    if (sock->state == 0U) {

      rval = (-2);
    }
    else {

      val = GetOpt (opt_val, opt_len);

      switch (opt_id) {
        case 1:
          if (val == 0U) {

            sock->flags &= ~(1U << 0);
          } else {

            sock->flags |= (1U << 0);
          }
          break;

        case 2:

          sock->tout_rx = val;
          break;

        case 3:

          sock->tout_tx = val;
          break;

        case 4:
          if (val == 0U) {

            sock->flags &=~ (1U << 1);
          } else {

            sock->flags |= (1U << 1);
          }
          break;

        default:
          rval = (-3);
          break;
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 3925 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketClose (int32_t socket) {
  int32_t ex, rval;
  uint32_t n;
  WIFI_SOCKET *sock;

  WiFi_ThreadKick();

  rval = 0;

  if ((socket < 0) || (socket >= 5)) {

    rval = (-2);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {

    WiFi_Wait ((1U << (14 + (socket))), 25);

    sock = &Socket[socket];

    if (sock->state == 0U) {
      rval = (-2);
    }
    else if (sock->state == 8U) {

      ex = AT_Cmd_TcpServer (1, 0U, 0U);

      if (ex == 0) {

        ex = WiFi_Wait ((1U << 0), (5000));

        if (ex == 0) {
          ex = AT_Resp_Generic();

          if (ex == 0) {

            sock->state = 0U;
          }
        }
      }

      if (ex == 0) {

        for (n = 0U; n < 5; n++) {
          if (Socket[n].server != 0xFF) {
            Socket[n].state = 0U;

            Socket[n].server = 0xFF;
            Socket[n].backlog = 0xFF;
          }
        }
      }
    }
    else if ((sock->state == 7U) || (sock->state == 4U)) {

      if (sock->backlog == 0xFF) {

        sock->state = 0U;
      } else {

        sock->state = 3U;
      }


      BufUninit (&sock->mem);
    }
    else {

      if ((sock->state > 3U) && (sock->state < 6U)) {

        sock->state = 6U;


        ex = AT_Cmd_ConnectionClose (1, sock->conn_id);

        if (ex == 0) {

          ex = WiFi_Wait ((1U << 0), (5000));

          if (ex == 0) {
            ex = AT_Resp_Generic();

            if (ex == 0) {



              BufUninit (&sock->mem);
            }
          }
          else {

            rval = (-1);
          }
        }
      }
      else {

        sock->state = 0U;
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 4056 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_SocketGetHostByName (const char *name, int32_t af, uint8_t *ip, uint32_t *ip_len) {
  int32_t ex, rval;

  rval = 0;

  if ((name == 0) || (ip == 0) || (ip_len == 0) || (*ip_len < 4U)) {
    rval = (-3);
  }
  else if ((af != 1) && (af != 2)) {
    rval = (-3);
  }
  else if (af == 2) {
    rval = (-4);
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = (-1);
  }
  else {
    ex = AT_Cmd_DnsFunction (1, name);

    if (ex != 0) {

      rval = (-1);
    }
    else {

      ex = WiFi_Wait ((1U << 0), 10*(5000));

      if (ex == 0) {

        ex = AT_Resp_Generic ();

        if (ex == 0) {
          *ip_len = 4U;
          (void)AT_Resp_DnsFunction (ip);
        }
        else {
          rval = (-16);
        }
      }
      else {

        rval = (-16);
      }
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = (-1);
    }
  }

  return (rval);
}
# 4125 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static int32_t ARM_WIFI_Ping (const uint8_t *ip, uint32_t ip_len) {
  int32_t ex, rval;
  uint32_t val;

  rval = 0;

  if ((ip == 0) || ((ip_len != 4U) && (ip_len != 16U))) {
    rval = -5;
  }
  else if (ip_len == 16U) {
    rval = -4;
  }
  else if (osMutexAcquire ((&WIFI_Ctrl)->mutex_id, 0xFFFFFFFFU) != osOK) {

    rval = -1;
  }
  else {
    ex = AT_Cmd_Ping (1, ip, 0);

    if (ex == 0) {

      ex = WiFi_Wait ((1U << 0), (5000));

      if (ex == 0) {

        ex = AT_Resp_Ping (&val);

        if (ex == 0) {
          if ((val & 0x80000000) != 0) {

            rval = -3;
          }
        }
      }
    }

    if (ex != 0) {
      rval = -1;
    }

    if (osMutexRelease ((&WIFI_Ctrl)->mutex_id) != osOK) {

      rval = -1;
    }
  }

  return (rval);
}


ARM_DRIVER_WIFI Driver_WiFi0 = {
  ARM_WIFI_GetVersion,
  ARM_WIFI_GetCapabilities,
  ARM_WIFI_Initialize,
  ARM_WIFI_Uninitialize,
  ARM_WIFI_PowerControl,
  ARM_WIFI_GetModuleInfo,
  ARM_WIFI_SetOption,
  ARM_WIFI_GetOption,
  ARM_WIFI_Scan,
  ARM_WIFI_Activate,
  ARM_WIFI_Deactivate,
  ARM_WIFI_IsConnected,
  ARM_WIFI_GetNetInfo,
  ARM_WIFI_BypassControl,
  ARM_WIFI_EthSendFrame,
  ARM_WIFI_EthReadFrame,
  ARM_WIFI_EthGetRxFrameSize,
  ARM_WIFI_SocketCreate,
  ARM_WIFI_SocketBind,
  ARM_WIFI_SocketListen,
  ARM_WIFI_SocketAccept,
  ARM_WIFI_SocketConnect,
  ARM_WIFI_SocketRecv,
  ARM_WIFI_SocketRecvFrom,
  ARM_WIFI_SocketSend,
  ARM_WIFI_SocketSendTo,
  ARM_WIFI_SocketGetSockName,
  ARM_WIFI_SocketGetPeerName,
  ARM_WIFI_SocketGetOpt,
  ARM_WIFI_SocketSetOpt,
  ARM_WIFI_SocketClose,
  ARM_WIFI_SocketGetHostByName,
  ARM_WIFI_Ping
};

static int32_t ResetModule (void) {
  int32_t rval, ex;

  ex = AT_Cmd_Reset();

  if (ex == 0) {

    ex = WiFi_Wait ((1U << 0), 5000);

    if (ex == 0) {

      ex = AT_Resp_Generic();

      if (ex == 0) {


        ex = WiFi_Wait ((1U << 0), 5000);

        if (ex == 0) {

          ex = AT_Resp_Generic();

          if (ex == 12) {

            ex = 0;
          }
        }
      }
    }
  }

  if (ex == 0) {
    rval = 0;
  } else {
    rval = -1;
  }

  return (rval);
}

static int32_t SetupCommunication (void) {
  int32_t rval, ex;
  int32_t state;
  uint32_t k;
  uint32_t stop_par_flowc;
  AT_PARSER_COM_SERIAL info;
  const uint32_t br[] = {115200, 115200,
                                               230400, 460800, 921600,
                                              1000000, 1500000, 2000000,
                                                57600, 38400, 19200, 9600};
  k = 0;
  state = 0;

  ex = AT_Parser_GetSerialCfg (&info);

  if (ex == 0) {

    info.databits = 8U;
    info.stopbits = 1U;
    info.parity = 0U;
    info.flow_control = 0U;
  }

  while (state < 3) {

    switch (state) {
      case 0:
      case 2:

        info.baudrate = br[k];

        ex = AT_Parser_SetSerialCfg (&info);

        if (ex != 0) {

          break;
        }


        ex = AT_Cmd_TestAT();
        break;

      case 1:

        stop_par_flowc = (info.stopbits << 4) |
                         (info.parity << 2) |
                          info.flow_control ;

        ex = AT_Cmd_ConfigUART (1, br[k], info.databits, stop_par_flowc);
        break;

      default:
        ex = -1;
        break;
    }

    if (ex != 0) {

      state = 4;
    }
    else {

      ex = WiFi_Wait ((1U << 0), 200);

      if (ex != 0) {

        AT_Parser_Reset();


        state = 0;


        k++;

        if (k == (sizeof(br)/sizeof(br[0]))) {

          state = 4;
        }
      }
      else {

        ex = AT_Resp_Generic();

        if (ex == 0) {
          if (state == 0) {

            if (k != 0) {

              k = 0;
            }
            else {

              state = 2;
            }
          }
        }


        state++;
      }
    }
  }

  if (ex == 0) {
    rval = 0;
  } else {
    rval = -1;
  }

  return (rval);
}

static int32_t LoadOptions (void) {
  int32_t ex;
  int32_t state;
  int32_t n;


  n = 4;


  ex = -1;
  state = 0;

  while (state < n) {
    switch (state) {
      case 0:
        ex = GetCurrentIpAddr (0, (&WIFI_Ctrl)->options.st_ip,
                                                       (&WIFI_Ctrl)->options.st_gateway,
                                                       (&WIFI_Ctrl)->options.st_netmask);
        break;

      case 1:
        ex = GetCurrentIpAddr (1, (&WIFI_Ctrl)->options.ap_ip,
                                                  (&WIFI_Ctrl)->options.ap_gateway,
                                                  (&WIFI_Ctrl)->options.ap_netmask);
        break;

      case 2:
        ex = GetCurrentMAC (1, (&WIFI_Ctrl)->options.ap_mac);
        break;

      case 3:
        ex = GetCurrentDhcpPool (&(&WIFI_Ctrl)->options.ap_dhcp_lease, (&WIFI_Ctrl)->options.ap_dhcp_pool_start,
                                                                (&WIFI_Ctrl)->options.ap_dhcp_pool_end);
        break;

      default:
        ex = -1;
        break;
    }

    if (ex != 0) {

      state = n;
    }
    else {

      state++;
    }
  }

  return (ex);
}

static int32_t IsUnspecifiedIP (const uint8_t ip[]) {
  int32_t rval;

  if ((ip[0] == 0U) && (ip[1] == 0U) && (ip[2] == 0U) && (ip[3] == 0U)) {

    rval = 1U;
  } else {
    rval = 0U;
  }

  return (rval);
}

static int32_t GetCurrentMAC (uint32_t interface, uint8_t mac[]) {
  int32_t ex;

  if (interface == 0) {
    ex = AT_Cmd_StationMAC (0, 0);
  } else {
    ex = AT_Cmd_AccessPointMAC (0, 0);
  }

  if (ex == 0) {

    ex = WiFi_Wait ((1U << 0), (5000));

    if (ex == 0) {

      if (interface == 0) {
        ex = AT_Resp_StationMAC (mac);
      } else {
        ex = AT_Resp_AccessPointMAC (mac);
      }
    }
  }

  return (ex);
}

static int32_t GetCurrentIpAddr (uint32_t interface, uint8_t ip[], uint8_t gw[], uint8_t mask[]) {
  int32_t ex;
  uint8_t *p;

  if (interface == 0) {
    ex = AT_Cmd_StationIP (0, 0, 0, 0);
  } else {
    ex = AT_Cmd_AccessPointIP (0, 0, 0, 0);
  }

  if (ex == 0) {

    ex = WiFi_Wait ((1U << 0), (5000));

    if (ex == 0) {

      p = ip;

      do {
        if (interface == 0) {
          ex = AT_Resp_StationIP (p);
        } else {
          ex = AT_Resp_AccessPointIP (p);
        }


        if (p == ip) { p = gw; }
        else { p = mask; }
      }
      while (ex == 1);
    }
  }
  return (ex);
}

static int32_t GetCurrentDhcpPool (uint32_t *t_lease, uint8_t ip_start[], uint8_t ip_end[]) {
  int32_t ex;

  ex = AT_Cmd_RangeDHCP(0, 0U, 0, 0);

  if (ex == 0) {

    ex = WiFi_Wait ((1U << 0), (5000));

    if (ex == 0) {

      ex = AT_Resp_RangeDHCP (t_lease, ip_start, ip_end);
    }
  }

  return (ex);
}

static int32_t GetCurrentDnsAddr (uint32_t interface, uint8_t dns0[], uint8_t dns1[]) {
  int32_t ex;
  uint8_t *p;
  (void)interface;

  ex = AT_Cmd_DNS (0, 0, 0, 0);

  if (ex == 0) {

    ex = WiFi_Wait ((1U << 0), (5000));

    if (ex == 0) {

      p = dns0;




      do {
        ex = AT_Resp_DNS (p);


        if (p == dns0) { p = dns1; }
        else { p = 0; }
      }
      while (ex == 1);

    }
  }
  return (ex);
}
# 4547 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static uint32_t GetOpt (const void *opt_val, uint32_t opt_len) {
  uint32_t val;


    (void)opt_len;

    val = (((const struct T_UINT32_READ *)(const void *)(opt_val))->v);
# 4568 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
  return (val);
}
# 4579 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
static uint32_t SetOpt (void *opt_val, uint32_t val, uint32_t opt_len) {
  uint32_t len;



    (void)((((struct T_UINT32_WRITE *)(void *)(opt_val))->v) = (val));

    len = opt_len;
# 4600 "C:/Users/shw26/AppData/Local/Arm/Packs/ARM/CMSIS-Driver/2.6.1/WiFi/ESP8266/WiFi_ESP8266.c"
  return (len);
}


static uint32_t ConnId_Alloc (void) {
  uint32_t bit;

  for (bit = 0; bit < 5; bit++) {
    if (((&WIFI_Ctrl)->conn_id & (1U << bit)) == 0) {
      break;
    }
  }

  return (bit);
}


static void ConnId_Free (uint32_t conn_id) {
  (&WIFI_Ctrl)->conn_id &= ~(1U << conn_id);
}


static void ConnId_Accept (uint32_t conn_id) {
  (&WIFI_Ctrl)->conn_id |= (1U << conn_id);
}
